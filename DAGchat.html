<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>DAGchat - Multi-Model DAG Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    </script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            padding: 0 12px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 16px;
            cursor: pointer;
            border: none;
            background: none;
            color: #888;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #e0e0e0;
        }

        .tab.active {
            color: #e0e0e0;
            border-bottom-color: #4a9eff;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }

        .tab-content.active {
            display: flex;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .message {
            margin-bottom: 20px;
            max-width: 85%;
        }

        .message.user {
            margin-left: auto;
            background: #2a4a7a;
            padding: 12px 16px;
            border-radius: 12px;
        }

        .message.assistant {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
        }

        .message.dag-execution {
            background: #1e2a1e;
            border: 1px solid #3a5a3a;
            max-width: 100%;
        }

        .dag-node-output {
            background: #2a2a2a;
            border-radius: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .dag-node-header {
            background: #3a3a3a;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .dag-node-header:hover {
            background: #4a4a4a;
        }

        .dag-node-header .node-name {
            font-weight: 600;
            font-size: 13px;
        }

        .dag-node-header .node-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: #4a4a4a;
        }

        .dag-node-header .node-status.streaming {
            background: #4a9eff;
            color: white;
        }

        .dag-node-header .node-status.complete {
            background: #4a8a4a;
            color: white;
        }

        .dag-node-header .node-status.waiting {
            background: #6a6a4a;
            color: white;
        }

        .dag-node-header .node-status.terminal {
            background: #9a4aff;
            color: white;
        }

        .dag-node-content {
            padding: 12px;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .dag-node-content.collapsed {
            display: none;
        }

        .dag-node-content.stripped {
            color: #888;
            font-style: italic;
        }

        .thinking-toggle {
            background: #3a2a1a;
            border: 1px solid #4a4a4a;
            color: #ff8c42;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 8px 0;
            display: inline-block;
            user-select: none;
        }

        .thinking-toggle:hover {
            background: #4a3a2a;
        }

        .thinking-content {
            background: #3a2a1a;
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #ff8c42;
            margin: 8px 0;
            font-style: italic;
            font-size: 13px;
            color: #d0d0d0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .thinking-content.collapsed {
            display: none;
        }

        .typing-indicator {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 85%;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            opacity: 0.7;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-indicator .dot {
            width: 8px;
            height: 8px;
            background: #4a9eff;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .message-content ol,
        .message-content ul {
            white-space: normal;
            margin: 8px 0;
            padding-left: 24px;
        }

        .message-content ol {
            list-style-type: decimal;
        }

        .message-content ul {
            list-style-type: disc;
        }

        .message-content li {
            white-space: pre-wrap;
            margin: 4px 0;
        }

        .message-content a {
            color: #4a9eff;
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        .message-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .message-actions button {
            background: #3a3a3a;
            border: none;
            color: #888;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .message-actions button:hover {
            background: #4a4a4a;
            color: #e0e0e0;
        }

        .file-preview {
            margin-top: 8px;
            max-width: 100%;
        }

        .file-preview img, .file-preview video {
            max-width: 100%;
            border-radius: 8px;
        }

        .file-info {
            background: #3a3a3a;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 8px;
        }

        #chat-input-area {
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            padding: 16px;
        }

        .input-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-controls, .send-controls {
            display: flex;
            gap: 8px;
        }

        .input-controls {
            width: 100%;
        }

        .input-controls button {
            flex: 1;
        }

        .send-controls {
            width: 100%;
        }

        .send-controls button {
            flex: 1;
        }

        #message-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 44px;
            max-height: 200px;
        }

        #message-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        #message-input.editing {
            border-color: #f0ad4e;
        }

        #edit-indicator {
            display: none;
            color: #f0ad4e;
            font-size: 12px;
            margin-bottom: 4px;
            align-items: center;
            gap: 8px;
        }

        #edit-indicator.visible {
            display: flex;
        }

        #edit-indicator button {
            background: transparent;
            border: none;
            color: #888;
            padding: 0;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }

        #edit-indicator button:hover {
            color: #e0e0e0;
        }

        .file-upload-btn, .model-select, #send-btn {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .model-select {
            min-width: 120px;
        }

        #send-btn {
            background: #4a9eff;
            border-color: #4a9eff;
            font-weight: 600;
        }

        #send-btn:hover {
            background: #3a8eef;
        }

        #send-btn:disabled {
            background: #3a3a3a;
            color: #666;
            cursor: not-allowed;
        }

        #stop-btn {
            background: #ff6b6b;
            border-color: #ff6b6b;
            font-weight: 600;
            display: none;
        }

        #stop-btn:hover {
            background: #ff5252;
        }

        .attached-files {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .attached-file {
            background: #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .attached-file button {
            background: #4a4a4a;
            border: none;
            color: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        /* DAG Editor Styles */
        #dag-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #dag-toolbar {
            background: #2a2a2a;
            padding: 12px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        #dag-toolbar button, #dag-toolbar select {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }

        #dag-toolbar button:hover {
            background: #4a4a4a;
        }

        #dag-toolbar button.active {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        #dag-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
            background-image:
                radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #dag-canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .dag-node {
            position: absolute;
            background: #2a2a2a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            min-width: 120px;
            cursor: move;
            user-select: none;
            touch-action: none;
        }

        .dag-node.selected {
            border-color: #4a9eff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
        }

        .dag-node.terminal {
            border-color: #9a4aff;
        }

        .dag-node-title {
            background: #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dag-node.terminal .dag-node-title {
            background: #4a3a5a;
        }

        .dag-node-body {
            padding: 8px 12px;
            font-size: 12px;
            color: #aaa;
        }

        .dag-node-ports {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px 8px;
        }

        .dag-port {
            width: 12px;
            height: 12px;
            background: #4a4a4a;
            border-radius: 50%;
            cursor: crosshair;
        }

        .dag-port.input {
            background: #4a9eff;
        }

        .dag-port.output {
            background: #4aff9e;
        }

        .dag-port:hover {
            transform: scale(1.3);
        }

        /* Settings styles */
        .settings-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .settings-section {
            background: #2a2a2a;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .settings-section h3 {
            margin-bottom: 12px;
            color: #4a9eff;
        }

        .settings-section input[type="text"],
        .settings-section input[type="number"],
        .settings-section textarea,
        .settings-section select {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 8px;
            font-family: inherit;
        }

        .settings-section textarea {
            min-height: 100px;
            resize: vertical;
        }

        .settings-section button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-section button:hover {
            background: #4a4a4a;
        }

        .settings-section button.primary {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .settings-section button.primary:hover {
            background: #3a8eef;
        }

        .settings-section button.danger {
            background: #ff4a4a;
            border-color: #ff4a4a;
        }

        .model-item, .api-key-item, .prompt-item {
            background: #3a3a3a;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .model-item h4, .api-key-item h4, .prompt-item h4 {
            margin-bottom: 4px;
        }

        .model-actions, .prompt-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .model-actions button, .prompt-actions button {
            padding: 4px 8px;
            font-size: 12px;
        }

        .history-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .history-item {
            background: #2a2a2a;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .history-item h4 {
            margin-bottom: 8px;
            color: #4a9eff;
        }

        .history-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .history-actions button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .history-actions button:hover {
            background: #4a4a4a;
        }

        /* DAG Config Panel */
        .dag-config-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 300px;
            background: #2a2a2a;
            border-left: 1px solid #3a3a3a;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .dag-config-panel.open {
            transform: translateX(0);
        }

        .dag-config-panel-header {
            padding: 16px;
            background: #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dag-config-panel-header h3 {
            margin: 0;
        }

        .dag-config-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .dag-config-panel label {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            color: #aaa;
        }

        .dag-config-panel input,
        .dag-config-panel select,
        .dag-config-panel textarea {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 12px;
            font-family: inherit;
        }

        .dag-config-panel textarea {
            min-height: 80px;
            resize: vertical;
        }

        .dag-config-panel button {
            width: 100%;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .dag-config-panel button:hover {
            background: #4a4a4a;
        }

        .dag-config-panel button.danger {
            background: #5a2a2a;
            border-color: #7a3a3a;
        }

        .dag-config-panel button.danger:hover {
            background: #7a3a3a;
        }

        /* Toggle switch for rotation */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .toggle-switch input[type="checkbox"] {
            width: 40px;
            height: 22px;
            appearance: none;
            background: #3a3a3a;
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            margin: 0;
        }

        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #888;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.2s;
        }

        .toggle-switch input[type="checkbox"]:checked {
            background: #4a9eff;
        }

        .toggle-switch input[type="checkbox"]:checked::before {
            background: white;
            left: 20px;
        }

        #file-input {
            display: none;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 8px;
            padding: 12px 16px;
            max-width: 350px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: toastSlideIn 0.3s ease;
            pointer-events: auto;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease forwards;
        }

        .toast-success {
            border-color: #4a8a4a;
        }

        .toast-success .toast-icon {
            color: #4aff9e;
        }

        .toast-error {
            border-color: #8a4a4a;
        }

        .toast-error .toast-icon {
            color: #ff6b6b;
        }

        .toast-warning {
            border-color: #8a7a4a;
        }

        .toast-warning .toast-icon {
            color: #ffcc42;
        }

        .toast-info {
            border-color: #4a7a8a;
        }

        .toast-info .toast-icon {
            color: #4a9eff;
        }

        .toast-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 12px;
            color: #aaa;
        }

        .toast-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 0;
            font-size: 16px;
            line-height: 1;
        }

        .toast-close:hover {
            color: #e0e0e0;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Edit Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: #2a2a2a;
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            padding: 16px 20px;
            background: #3a3a3a;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .modal-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .modal-body textarea {
            width: 100%;
            min-height: 200px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .modal-body textarea:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #3a3a3a;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-footer button {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            border: 1px solid #4a4a4a;
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .modal-footer button:hover {
            background: #4a4a4a;
        }

        .modal-footer button.primary {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .modal-footer button.primary:hover {
            background: #3a8eef;
        }

        @media (max-width: 768px) {
            .message {
                max-width: 95%;
            }

            .input-row {
                flex-wrap: wrap;
            }

            .dag-config-panel {
                width: 100%;
            }

            .dag-node {
                min-width: 100px;
            }

            .dag-port {
                width: 20px;
                height: 20px;
            }

            #dag-toolbar {
                padding: 8px;
                gap: 6px;
            }

            #dag-toolbar button, #dag-toolbar select {
                padding: 10px 8px;
                font-size: 12px;
            }

            .dag-zoom-controls {
                bottom: 10px;
                right: 10px;
            }

            .dag-zoom-controls button {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        /* DAG Zoom Controls */
        .dag-zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        .dag-zoom-controls button {
            width: 36px;
            height: 36px;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dag-zoom-controls button:hover {
            background: #3a3a3a;
        }

        .dag-zoom-controls button:active {
            background: #4a4a4a;
        }

        .dag-zoom-level {
            text-align: center;
            font-size: 11px;
            color: #888;
            padding: 2px 0;
        }

        /* DAG Canvas Transform */
        #dag-canvas-wrapper {
            transform-origin: 0 0;
            position: absolute;
            top: 0;
            left: 0;
            min-width: 100%;
            min-height: 100%;
        }

        #dag-canvas-container.panning {
            cursor: grab;
        }

        #dag-canvas-container.panning:active {
            cursor: grabbing;
        }

        /* Help Overlay */
        .dag-help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .dag-help-overlay.open {
            display: flex;
        }

        .dag-help-content {
            background: #2a2a2a;
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .dag-help-header {
            padding: 16px 20px;
            background: #3a3a3a;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
        }

        .dag-help-header h3 {
            margin: 0;
            color: #4a9eff;
        }

        .dag-help-body {
            padding: 20px;
        }

        .dag-help-section {
            margin-bottom: 20px;
        }

        .dag-help-section h4 {
            color: #4aff9e;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .dag-help-section ul {
            list-style: none;
            padding: 0;
        }

        .dag-help-section li {
            padding: 8px 0;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            gap: 10px;
            font-size: 14px;
        }

        .dag-help-section li:last-child {
            border-bottom: none;
        }

        .dag-help-key {
            background: #3a3a3a;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: nowrap;
            color: #4a9eff;
        }

        .dag-help-action {
            color: #aaa;
        }

        /* Toolbar help button */
        #dag-toolbar .help-btn {
            background: #3a5a3a;
            border-color: #4a7a4a;
        }

        #dag-toolbar .help-btn:hover {
            background: #4a7a4a;
        }

        /* Delete button styling */
        #dag-toolbar .delete-btn {
            background: #5a3a3a;
            border-color: #7a4a4a;
        }

        #dag-toolbar .delete-btn:hover {
            background: #7a4a4a;
        }

        #dag-toolbar .delete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Context menu for edges */
        .dag-edge-menu {
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            padding: 4px 0;
            z-index: 1000;
            min-width: 120px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .dag-edge-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
        }

        .dag-edge-menu button:hover {
            background: #3a3a3a;
        }

        .dag-edge-menu button.danger {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div id="toast-container" class="toast-container"></div>

    <!-- DAG Help Overlay -->
    <div id="dag-help-overlay" class="dag-help-overlay" onclick="if(event.target === this) closeDagHelp()">
        <div class="dag-help-content">
            <div class="dag-help-header">
                <h3>DAG Editor Help</h3>
                <button onclick="closeDagHelp()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">×</button>
            </div>
            <div class="dag-help-body">
                <div class="dag-help-section">
                    <h4>Creating Nodes</h4>
                    <ul>
                        <li><span class="dag-help-key">+ Add Node</span><span class="dag-help-action">Create a new model node</span></li>
                        <li><span class="dag-help-key">Templates</span><span class="dag-help-action">Load pre-built workflow patterns</span></li>
                    </ul>
                </div>
                <div class="dag-help-section">
                    <h4>Editing Nodes</h4>
                    <ul>
                        <li><span class="dag-help-key">Click</span><span class="dag-help-action">Select a node</span></li>
                        <li><span class="dag-help-key">Double-click</span><span class="dag-help-action">Open node settings</span></li>
                        <li><span class="dag-help-key">Drag</span><span class="dag-help-action">Move a node</span></li>
                        <li><span class="dag-help-key">Delete / Backspace</span><span class="dag-help-action">Delete selected node</span></li>
                        <li><span class="dag-help-key">Delete Node button</span><span class="dag-help-action">Delete selected node (mobile-friendly)</span></li>
                    </ul>
                </div>
                <div class="dag-help-section">
                    <h4>Creating Connections (Edges)</h4>
                    <ul>
                        <li><span class="dag-help-key">Drag from green port</span><span class="dag-help-action">Start drawing an edge from output</span></li>
                        <li><span class="dag-help-key">Drop on blue port</span><span class="dag-help-action">Connect to another node's input</span></li>
                        <li><span class="dag-help-key">Click edge</span><span class="dag-help-action">Delete the connection</span></li>
                    </ul>
                </div>
                <div class="dag-help-section">
                    <h4>Navigation</h4>
                    <ul>
                        <li><span class="dag-help-key">Mouse wheel</span><span class="dag-help-action">Zoom in/out</span></li>
                        <li><span class="dag-help-key">Pinch (touch)</span><span class="dag-help-action">Zoom in/out on mobile</span></li>
                        <li><span class="dag-help-key">Two-finger drag</span><span class="dag-help-action">Pan the canvas on mobile</span></li>
                        <li><span class="dag-help-key">Middle-click drag</span><span class="dag-help-action">Pan the canvas</span></li>
                        <li><span class="dag-help-key">+ / − buttons</span><span class="dag-help-action">Zoom controls</span></li>
                        <li><span class="dag-help-key">⟲ button</span><span class="dag-help-action">Reset zoom and pan</span></li>
                        <li><span class="dag-help-key">⊡ button</span><span class="dag-help-action">Fit all nodes to view</span></li>
                    </ul>
                </div>
                <div class="dag-help-section">
                    <h4>Keyboard Shortcuts</h4>
                    <ul>
                        <li><span class="dag-help-key">Ctrl+Z</span><span class="dag-help-action">Undo</span></li>
                        <li><span class="dag-help-key">Ctrl+Y</span><span class="dag-help-action">Redo</span></li>
                        <li><span class="dag-help-key">Ctrl+C</span><span class="dag-help-action">Copy selected node</span></li>
                        <li><span class="dag-help-key">Ctrl+V</span><span class="dag-help-action">Paste node</span></li>
                        <li><span class="dag-help-key">Escape</span><span class="dag-help-action">Deselect / close panels</span></li>
                    </ul>
                </div>
                <div class="dag-help-section">
                    <h4>Node Ports</h4>
                    <ul>
                        <li><span class="dag-help-key" style="background: #4a9eff;">Blue port</span><span class="dag-help-action">Input - receives data from other nodes</span></li>
                        <li><span class="dag-help-key" style="background: #4aff9e; color: #1a1a1a;">Green port</span><span class="dag-help-action">Output - sends data to other nodes</span></li>
                        <li><span class="dag-help-key" style="background: #9a4aff;">★ Purple star</span><span class="dag-help-action">Terminal node - output shown to user</span></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 id="edit-modal-title">Edit Response</h3>
                <button onclick="closeEditModal()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">×</button>
            </div>
            <div class="modal-body">
                <textarea id="edit-modal-content" placeholder="Enter content..."></textarea>
            </div>
            <div class="modal-footer">
                <button onclick="closeEditModal()">Cancel</button>
                <button class="primary" onclick="saveEditModal()">Save</button>
            </div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab active" data-tab="chat">Chat</button>
        <button class="tab" data-tab="dag">DAG</button>
        <button class="tab" data-tab="history">History</button>
        <button class="tab" data-tab="settings">Settings</button>
    </div>

    <div id="chat-tab" class="tab-content active">
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <div class="attached-files" id="attached-files"></div>
            <div class="input-row">
                <input type="file" id="file-input" multiple accept="*/*">
                <div class="input-controls">
                    <button class="file-upload-btn" onclick="document.getElementById('file-input').click()">Attach</button>
                    <button class="model-select" onclick="switchTab('dag')">Edit DAG</button>
                    <button class="model-select" onclick="newChat()">New Chat</button>
                </div>
                <div id="edit-indicator">
                    <span>editing</span>
                    <button onclick="cancelEditMode()">cancel</button>
                </div>
                <textarea id="message-input" placeholder="Type a message..."></textarea>
                <div class="send-controls">
                    <button id="send-btn">Send</button>
                    <button id="stop-btn">Stop</button>
                </div>
            </div>
        </div>
    </div>

    <div id="dag-tab" class="tab-content">
        <div id="dag-editor-container">
            <div id="dag-toolbar">
                <button onclick="addDagNode()">+ Add Node</button>
                <button id="delete-node-btn" class="delete-btn" onclick="deleteSelectedNode()" disabled>Delete Node</button>
                <select id="dag-template-select" onchange="loadDagTemplate(this.value)">
                    <option value="">Templates...</option>
                    <option value="single">Single Model</option>
                    <option value="chain">Chain (A→B→C)</option>
                    <option value="parallel">Parallel</option>
                    <option value="diamond">Diamond</option>
                    <option value="debate">Debate</option>
                    <option value="critic">Critic Loop</option>
                    <option value="ensemble">Ensemble (3-way)</option>
                </select>
                <button onclick="autoLayoutDag()">Auto Layout</button>
                <div class="toggle-switch">
                    <input type="checkbox" id="dag-rotation-toggle" onchange="toggleDagRotation()">
                    <label for="dag-rotation-toggle">Rotation</label>
                </div>
                <button onclick="openDagSettings()">⚙ Settings</button>
                <button onclick="exportDag()">Export</button>
                <button onclick="importDag()">Import</button>
                <button class="help-btn" onclick="openDagHelp()">? Help</button>
                <button onclick="clearDag()" style="margin-left: auto;">Clear</button>
            </div>
            <div id="dag-canvas-container">
                <div id="dag-canvas-wrapper">
                    <svg id="dag-canvas"></svg>
                </div>
                <div class="dag-zoom-controls">
                    <button onclick="zoomDag(0.1)" title="Zoom In">+</button>
                    <div class="dag-zoom-level" id="dag-zoom-level">100%</div>
                    <button onclick="zoomDag(-0.1)" title="Zoom Out">−</button>
                    <button onclick="resetDagView()" title="Reset View" style="margin-top: 4px; font-size: 12px;">⟲</button>
                    <button onclick="fitDagToView()" title="Fit to View" style="font-size: 12px;">⊡</button>
                </div>
            </div>
        </div>
    </div>

    <div id="history-tab" class="tab-content">
        <div class="history-container">
            <div class="settings-section">
                <h3>Conversation History</h3>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="primary" onclick="exportConversation()">Export</button>
                    <button class="primary" onclick="document.getElementById('import-history-input').click()">Import</button>
                    <button onclick="clearHistory()">Clear All</button>
                </div>
                <input type="file" id="import-history-input" accept=".json" style="display: none;" onchange="importHistory(event)">
            </div>
            <div id="history-list"></div>
        </div>
    </div>

    <div id="settings-tab" class="tab-content">
        <div class="settings-container">
            <div class="settings-section">
                <h3>API Keys</h3>
                <input type="text" id="new-api-key-name" placeholder="Key name (e.g., OpenRouter)">
                <input type="text" id="new-api-key-value" placeholder="API key value">
                <button class="primary" onclick="addApiKey()">Add API Key</button>
                <div id="api-keys-list" style="margin-top: 12px;"></div>
            </div>

            <div class="settings-section">
                <h3>System Prompts</h3>
                <input type="text" id="new-prompt-name" placeholder="Prompt name">
                <textarea id="new-prompt-content" placeholder="System prompt content..."></textarea>
                <button class="primary" onclick="addSystemPrompt()">Add Prompt</button>
                <div id="prompts-list" style="margin-top: 12px;"></div>
            </div>

            <div class="settings-section">
                <h3>Global Settings</h3>
                <label>User Identifier (for multi-model chats):</label>
                <input type="text" id="user-identifier-input" placeholder="Human" onchange="saveUserIdentifier()">
                <div class="toggle-switch">
                    <input type="checkbox" id="latex-toggle" onchange="toggleLatex()">
                    <label for="latex-toggle">Enable LaTeX rendering</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="markdown-toggle" onchange="toggleMarkdown()">
                    <label for="markdown-toggle">Enable Markdown rendering</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="thinking-toggle" onchange="toggleThinkingMode()">
                    <label for="thinking-toggle">Enable extended thinking</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="background-audio-toggle" onchange="toggleBackgroundAudio()">
                    <label for="background-audio-toggle">Keep alive in background (iOS)</label>
                </div>
            </div>

            <div class="settings-section">
                <h3>Models</h3>
                <button class="primary" onclick="fetchOpenRouterModels()">Browse OpenRouter Models</button>
                <div id="models-browser" style="max-height: 300px; overflow-y: auto; margin-top: 12px; display: none;"></div>
                <hr style="border-color: #3a3a3a; margin: 16px 0;">
                <h4>Add New Model</h4>
                <input type="text" id="new-model-name" placeholder="Model name (e.g., Claude 3.5)">
                <textarea id="new-model-config" placeholder='{"endpoint": "https://openrouter.ai/api/v1/chat/completions", "model_id": "anthropic/claude-3.5-sonnet", "api_key_id": "your-key-id"}'></textarea>
                <button class="primary" onclick="addModel()">Add Model</button>
                <div id="models-list" style="margin-top: 12px;"></div>
            </div>

            <div class="settings-section">
                <h3>Export/Import All Data</h3>
                <button onclick="exportData()">Export All</button>
                <button onclick="document.getElementById('import-input').click()">Import</button>
                <input type="file" id="import-input" accept=".json" style="display: none;" onchange="importData(event)">
            </div>
        </div>
    </div>

    <!-- DAG Node Config Panel -->
    <div id="dag-config-panel" class="dag-config-panel">
        <div class="dag-config-panel-header">
            <h3>Node Settings</h3>
            <button onclick="closeDagConfigPanel()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">×</button>
        </div>
        <div class="dag-config-panel-body">
            <label>Model:</label>
            <select id="node-model-select"></select>

            <label>System Prompt:</label>
            <select id="node-prompt-select">
                <option value="">Inherit from DAG</option>
            </select>
            <textarea id="node-custom-prompt" placeholder="Or enter custom prompt..."></textarea>

            <label>Context Mode:</label>
            <select id="node-context-mode">
                <option value="inputs-only">Inputs Only</option>
                <option value="inputs-plus-user">Inputs + User Message</option>
                <option value="full-history">Full History</option>
            </select>

            <div class="toggle-switch">
                <input type="checkbox" id="node-strip-reasoning">
                <label for="node-strip-reasoning">Strip reasoning from output</label>
            </div>

            <div class="toggle-switch">
                <input type="checkbox" id="node-is-terminal">
                <label for="node-is-terminal">Terminal node (output to user)</label>
            </div>

            <button onclick="saveNodeConfig()" class="primary" style="background: #4a9eff; border-color: #4a9eff;">Save</button>
            <button onclick="deleteSelectedNode()" class="danger">Delete Node</button>
        </div>
    </div>

    <!-- DAG Settings Panel -->
    <div id="dag-settings-panel" class="dag-config-panel">
        <div class="dag-config-panel-header">
            <h3>DAG Settings</h3>
            <button onclick="closeDagSettingsPanel()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">×</button>
        </div>
        <div class="dag-config-panel-body">
            <label>Global System Prompt:</label>
            <select id="dag-global-prompt-select">
                <option value="">None</option>
            </select>
            <textarea id="dag-custom-prompt" placeholder="Or enter custom global prompt..."></textarea>

            <label>Message History Limit (0 = all):</label>
            <input type="number" id="dag-history-limit" min="0" value="0">

            <label>Response Delay (ms):</label>
            <input type="number" id="dag-response-delay" min="0" value="500">

            <div class="toggle-switch">
                <input type="checkbox" id="dag-include-files">
                <label for="dag-include-files">Include files in history</label>
            </div>

            <div class="toggle-switch">
                <input type="checkbox" id="dag-model-identity">
                <label for="dag-model-identity">Enable model identity</label>
            </div>

            <button onclick="saveDagSettings()" class="primary" style="background: #4a9eff; border-color: #4a9eff;">Save Settings</button>
        </div>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const CONFIG = {
            // Storage & History
            MAX_CONVERSATION_HISTORY: 50,          // Max saved conversations
            MAX_MODELS_BROWSER_RESULTS: 100,       // Models shown in browser
            MAX_FILTERED_MODELS: 50,               // Filtered model results

            // DAG Defaults
            DEFAULT_RESPONSE_DELAY: 500,           // ms between node executions
            DEFAULT_HISTORY_LIMIT: 0,              // 0 = unlimited

            // UI
            NODE_WIDTH: 120,                       // DAG node width for positioning
            NODE_HEIGHT: 80,                       // DAG node height for positioning
            TOAST_DURATION: 3000,                  // Toast notification duration ms
            TOAST_ERROR_DURATION: 5000,            // Error toast duration ms

            // Performance
            RENDER_DEBOUNCE_MS: 16,                // ~60fps for render scheduling

            // Database
            DB_NAME: 'DAGchatDB',
            DB_VERSION: 1,
            DB_STORE_NAME: 'settings'
        };

        // Error types for better error handling
        class DAGError extends Error {
            constructor(message, code) {
                super(message);
                this.name = 'DAGError';
                this.code = code;
            }
        }

        class APIError extends Error {
            constructor(message, status, details) {
                super(message);
                this.name = 'APIError';
                this.status = status;
                this.details = details;
            }
        }

        // ==================== STATE ====================
        // Unified application state
        const state = {
            // Data
            models: [],
            apiKeys: [],
            systemPrompts: [],
            currentConversation: [],
            conversationHistory: [],
            attachedFiles: [],

            // DAG
            dag: {
                nodes: {},
                edges: {},
                terminalNode: null,
                globalSystemPrompt: null,
                globalCustomPrompt: '',
                rotation: { enabled: false, index: 0 },
                settings: {
                    historyLimit: CONFIG.DEFAULT_HISTORY_LIMIT,
                    responseDelay: CONFIG.DEFAULT_RESPONSE_DELAY,
                    includeFiles: false,
                    modelIdentity: true
                }
            },

            // Undo/Redo history for DAG operations
            dagHistory: [],
            dagHistoryIndex: -1,

            // Clipboard for copy/paste
            clipboard: null,

            // UI State
            ui: {
                editingMessageIndex: null,
                selectedNodeId: null,
                isDraggingNode: false,
                isDrawingEdge: false,
                dragOffset: { x: 0, y: 0 },
                edgeStartNode: null,
                tempEdgeLine: null
            },

            // Streaming State
            streaming: {
                active: false,
                userStopped: false,
                abortControllers: [],
                renderTimer: null
            },

            // Settings
            settings: {
                userIdentifier: 'Human',
                enableLatexRendering: false,
                enableMarkdownRendering: false,
                enableExtendedThinking: false,
                enableBackgroundAudio: false,
                thinkingEffort: 'high'
            },

            // Audio
            audio: {
                context: null,
                silentNode: null
            },

            // Database
            db: null
        };

        // Legacy aliases for gradual migration (will remove as we update functions)
        let models = state.models;
        let apiKeys = state.apiKeys;
        let systemPrompts = state.systemPrompts;
        let currentConversation = state.currentConversation;
        let conversationHistory = state.conversationHistory;
        let attachedFiles = state.attachedFiles;
        let editingMessageIndex = null;
        let isStreaming = false;
        let userStoppedGeneration = false;
        let currentAbortControllers = [];
        let renderTimer = null;
        let dag = state.dag;
        let selectedNodeId = null;
        let isDraggingNode = false;
        let isDrawingEdge = false;
        let dragOffset = { x: 0, y: 0 };
        let edgeStartNode = null;
        let tempEdgeLine = null;
        let userIdentifier = 'Human';
        let enableLatexRendering = false;
        let enableMarkdownRendering = false;
        let enableExtendedThinking = false;
        let enableBackgroundAudio = false;
        let thinkingEffort = 'high';
        let audioContext = null;
        let silentAudioNode = null;
        let db = null;

        // ==================== INITIALIZATION ====================
        async function init() {
            await loadFromStorage();
            if (enableLatexRendering) await loadKaTeX();
            if (enableMarkdownRendering) await loadSnarkdown();
            setupEventListeners();
            setupKeyboardShortcuts();

            // Initialize DAG history with current state
            saveDagSnapshot();

            updateModelsList();
            updateApiKeysList();
            updatePromptsList();
            updateUserIdentifierInput();
            renderConversation();
            renderHistory();
            renderDag();
        }

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('DAGchatDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }
                };
            });
        }

        async function saveData(key, value) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readwrite');
                const store = transaction.objectStore('settings');
                const request = store.put(value, key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function loadData(key, defaultValue = null) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readonly');
                const store = transaction.objectStore('settings');
                const request = store.get(key);
                request.onsuccess = () => {
                    resolve(request.result !== undefined ? request.result : defaultValue);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function loadFromStorage() {
            try {
                await initDB();
                models = await loadData('models', []);
                apiKeys = await loadData('apiKeys', []);
                systemPrompts = await loadData('systemPrompts', []);
                currentConversation = await loadData('currentConversation', []);
                conversationHistory = await loadData('conversationHistory', []);
                dag = await loadData('dag', dag);
                userIdentifier = await loadData('userIdentifier', 'Human');
                enableLatexRendering = await loadData('enableLatexRendering', false);
                enableMarkdownRendering = await loadData('enableMarkdownRendering', false);
                enableExtendedThinking = await loadData('enableExtendedThinking', false);
                enableBackgroundAudio = await loadData('enableBackgroundAudio', false);
                thinkingEffort = await loadData('thinkingEffort', 'high');

                // Update UI toggles
                document.getElementById('latex-toggle').checked = enableLatexRendering;
                document.getElementById('markdown-toggle').checked = enableMarkdownRendering;
                document.getElementById('thinking-toggle').checked = enableExtendedThinking;
                document.getElementById('background-audio-toggle').checked = enableBackgroundAudio;
                document.getElementById('dag-rotation-toggle').checked = dag.rotation?.enabled || false;
            } catch (e) {
                console.error('Error loading from storage:', e);
            }
        }

        async function saveToStorage() {
            try {
                await saveData('models', models);
                await saveData('apiKeys', apiKeys);
                await saveData('systemPrompts', systemPrompts);
                await saveData('currentConversation', currentConversation);
                await saveData('conversationHistory', conversationHistory);
                await saveData('dag', dag);
                await saveData('userIdentifier', userIdentifier);
                await saveData('enableLatexRendering', enableLatexRendering);
                await saveData('enableMarkdownRendering', enableMarkdownRendering);
                await saveData('enableExtendedThinking', enableExtendedThinking);
                await saveData('enableBackgroundAudio', enableBackgroundAudio);
                await saveData('thinkingEffort', thinkingEffort);
            } catch (e) {
                console.error('Error saving to storage:', e);
            }
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });

            // Send message
            document.getElementById('send-btn').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Stop button
            document.getElementById('stop-btn').addEventListener('click', stopGeneration);

            // File upload
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // DAG canvas interactions
            const canvas = document.getElementById('dag-canvas-container');
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleCanvasTouchEnd);

            // Double-click to edit node
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);

            // Zoom with mouse wheel
            canvas.addEventListener('wheel', handleDagWheel, { passive: false });

            // Pan with middle mouse button
            canvas.addEventListener('mousedown', startPanning);
            canvas.addEventListener('mousemove', handlePanning);
            canvas.addEventListener('mouseup', stopPanning);
            canvas.addEventListener('mouseleave', stopPanning);

            // Touch pinch-to-zoom and two-finger pan
            canvas.addEventListener('touchstart', handleDagTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleDagTouchMove, { passive: false });

            // Prevent context menu on middle click
            canvas.addEventListener('contextmenu', (e) => {
                if (e.button === 1) e.preventDefault();
            });
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');

            if (tabName === 'dag') {
                renderDag();
            }
        }

        // ==================== DAG EDITOR ====================
        function generateId() {
            return 'id-' + Math.random().toString(36).substr(2, 9);
        }

        function addDagNode() {
            if (models.length === 0) {
                toastWarning('Please add at least one model in Settings first.');
                return;
            }

            saveDagSnapshot();  // Save for undo

            const id = generateId();
            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();

            // Position in the center of current view, accounting for zoom/pan
            const centerX = (rect.width / 2 - dagView.panX) / dagView.zoom;
            const centerY = (rect.height / 2 - dagView.panY) / dagView.zoom;

            dag.nodes[id] = {
                id: id,
                modelIndex: 0,
                position: {
                    x: centerX + (Math.random() - 0.5) * 100,
                    y: centerY + (Math.random() - 0.5) * 80
                },
                systemPrompt: null,
                customPrompt: '',
                config: {
                    contextMode: 'inputs-plus-user',
                    stripReasoning: false
                }
            };

            // If this is the first node, make it terminal
            if (Object.keys(dag.nodes).length === 1) {
                dag.terminalNode = id;
            }

            saveToStorage();
            renderDag();
        }

        function renderDag() {
            const container = document.getElementById('dag-canvas-container');
            const wrapper = document.getElementById('dag-canvas-wrapper');
            const svg = document.getElementById('dag-canvas');

            // Clear existing nodes (not SVG)
            wrapper.querySelectorAll('.dag-node').forEach(n => n.remove());

            // Clear SVG
            svg.innerHTML = '';

            // Add arrow marker definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#4a9eff"/>
                </marker>
            `;
            svg.appendChild(defs);

            // Render edges
            Object.values(dag.edges).forEach(edge => {
                const fromNode = dag.nodes[edge.from];
                const toNode = dag.nodes[edge.to];
                if (!fromNode || !toNode) return;

                // Create a wider invisible hit area for easier clicking
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hitArea.setAttribute('x1', fromNode.position.x + 60);
                hitArea.setAttribute('y1', fromNode.position.y + 50);
                hitArea.setAttribute('x2', toNode.position.x + 60);
                hitArea.setAttribute('y2', toNode.position.y + 10);
                hitArea.setAttribute('stroke', 'transparent');
                hitArea.setAttribute('stroke-width', '16');
                hitArea.style.cursor = 'pointer';
                hitArea.dataset.edgeId = edge.id;
                hitArea.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteEdge(edge.id);
                });
                svg.appendChild(hitArea);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromNode.position.x + 60);
                line.setAttribute('y1', fromNode.position.y + 50);
                line.setAttribute('x2', toNode.position.x + 60);
                line.setAttribute('y2', toNode.position.y + 10);
                line.setAttribute('stroke', '#4a9eff');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                line.style.cursor = 'pointer';
                line.style.pointerEvents = 'none';
                line.dataset.edgeId = edge.id;
                svg.appendChild(line);
            });

            // Render nodes
            Object.values(dag.nodes).forEach(node => {
                const div = document.createElement('div');
                div.className = 'dag-node' + (node.id === selectedNodeId ? ' selected' : '') + (node.id === dag.terminalNode ? ' terminal' : '');
                div.dataset.nodeId = node.id;
                div.style.left = node.position.x + 'px';
                div.style.top = node.position.y + 'px';

                const model = models[node.modelIndex] || { name: 'No Model' };
                const isTerminal = node.id === dag.terminalNode;

                div.innerHTML = `
                    <div class="dag-node-title">
                        <span>${escapeHtml(model.name)}</span>
                        ${isTerminal ? '<span style="color: #9a4aff;">★</span>' : ''}
                    </div>
                    <div class="dag-node-body">
                        ${node.config.contextMode}
                        ${node.config.stripReasoning ? ' • stripped' : ''}
                    </div>
                    <div class="dag-node-ports">
                        <div class="dag-port input" data-port="input" data-node="${node.id}"></div>
                        <div class="dag-port output" data-port="output" data-node="${node.id}"></div>
                    </div>
                `;

                wrapper.appendChild(div);
            });

            // Update rotation toggle
            document.getElementById('dag-rotation-toggle').checked = dag.rotation?.enabled || false;

            // Update delete button state
            const deleteBtn = document.getElementById('delete-node-btn');
            if (deleteBtn) {
                deleteBtn.disabled = !selectedNodeId;
            }
        }

        // Convert screen coordinates to canvas coordinates (accounting for zoom/pan)
        function screenToCanvas(clientX, clientY) {
            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();
            const screenX = clientX - rect.left;
            const screenY = clientY - rect.top;
            return {
                x: (screenX - dagView.panX) / dagView.zoom,
                y: (screenY - dagView.panY) / dagView.zoom
            };
        }

        function handleCanvasMouseDown(e) {
            // Ignore if panning
            if (e.button === 1) return;

            const node = e.target.closest('.dag-node');
            const port = e.target.closest('.dag-port');

            if (port) {
                // Start drawing edge
                const nodeId = port.dataset.node;
                const portType = port.dataset.port;

                if (portType === 'output') {
                    isDrawingEdge = true;
                    edgeStartNode = nodeId;

                    const svg = document.getElementById('dag-canvas');
                    tempEdgeLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    const startNode = dag.nodes[nodeId];
                    tempEdgeLine.setAttribute('x1', startNode.position.x + 60);
                    tempEdgeLine.setAttribute('y1', startNode.position.y + 50);
                    const canvasCoords = screenToCanvas(e.clientX, e.clientY);
                    tempEdgeLine.setAttribute('x2', canvasCoords.x);
                    tempEdgeLine.setAttribute('y2', canvasCoords.y);
                    tempEdgeLine.setAttribute('stroke', '#4a9eff');
                    tempEdgeLine.setAttribute('stroke-width', '2');
                    tempEdgeLine.setAttribute('stroke-dasharray', '5,5');
                    svg.appendChild(tempEdgeLine);
                }
                e.preventDefault();
                return;
            }

            if (node) {
                // Start dragging node
                selectedNodeId = node.dataset.nodeId;
                isDraggingNode = true;
                const nodeData = dag.nodes[selectedNodeId];
                const canvasCoords = screenToCanvas(e.clientX, e.clientY);
                dragOffset.x = canvasCoords.x - nodeData.position.x;
                dragOffset.y = canvasCoords.y - nodeData.position.y;
                renderDag();
                e.preventDefault();
            } else {
                // Deselect
                selectedNodeId = null;
                closeDagConfigPanel();
                renderDag();
            }
        }

        function handleCanvasMouseMove(e) {
            if (isDraggingNode && selectedNodeId) {
                const canvasCoords = screenToCanvas(e.clientX, e.clientY);
                const newX = canvasCoords.x - dragOffset.x;
                const newY = canvasCoords.y - dragOffset.y;

                // Update state
                dag.nodes[selectedNodeId].position.x = newX;
                dag.nodes[selectedNodeId].position.y = newY;

                // Update node element directly (no full re-render)
                const wrapper = document.getElementById('dag-canvas-wrapper');
                const nodeEl = wrapper.querySelector(`[data-node-id="${selectedNodeId}"]`);
                if (nodeEl) {
                    nodeEl.style.left = newX + 'px';
                    nodeEl.style.top = newY + 'px';
                }

                // Update connected edges directly
                updateEdgesForNode(selectedNodeId);
            }

            if (isDrawingEdge && tempEdgeLine) {
                const canvasCoords = screenToCanvas(e.clientX, e.clientY);
                tempEdgeLine.setAttribute('x2', canvasCoords.x);
                tempEdgeLine.setAttribute('y2', canvasCoords.y);
            }
        }

        // Efficiently update just the edges connected to a specific node
        function updateEdgesForNode(nodeId) {
            const svg = document.getElementById('dag-canvas');
            const node = dag.nodes[nodeId];
            if (!node) return;

            for (const edge of Object.values(dag.edges)) {
                if (edge.from === nodeId || edge.to === nodeId) {
                    // Update all lines with this edge id (hit area + visible line)
                    const lines = svg.querySelectorAll(`[data-edge-id="${edge.id}"]`);
                    const fromNode = dag.nodes[edge.from];
                    const toNode = dag.nodes[edge.to];
                    if (fromNode && toNode) {
                        lines.forEach(line => {
                            line.setAttribute('x1', fromNode.position.x + 60);
                            line.setAttribute('y1', fromNode.position.y + 50);
                            line.setAttribute('x2', toNode.position.x + 60);
                            line.setAttribute('y2', toNode.position.y + 10);
                        });
                    }
                }
            }
        }

        function handleCanvasMouseUp(e) {
            if (isDraggingNode) {
                isDraggingNode = false;
                saveDagSnapshot();  // Save for undo after drag
                saveToStorage();
            }

            if (isDrawingEdge) {
                const port = e.target.closest('.dag-port');
                if (port && port.dataset.port === 'input' && port.dataset.node !== edgeStartNode) {
                    // Create edge
                    const toNodeId = port.dataset.node;

                    // Check for cycles
                    if (!wouldCreateCycle(edgeStartNode, toNodeId)) {
                        saveDagSnapshot();  // Save for undo
                        const edgeId = generateId();
                        dag.edges[edgeId] = {
                            id: edgeId,
                            from: edgeStartNode,
                            to: toNodeId,
                            transform: 'full'
                        };
                        saveToStorage();
                    } else {
                        toastError('Cannot create edge: would create a cycle');
                    }
                }

                isDrawingEdge = false;
                edgeStartNode = null;
                if (tempEdgeLine) {
                    tempEdgeLine.remove();
                    tempEdgeLine = null;
                }
                renderDag();
            }
        }

        function handleCanvasTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const fakeEvent = {
                    target: document.elementFromPoint(touch.clientX, touch.clientY),
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0, // Simulate left click
                    preventDefault: () => e.preventDefault()
                };
                handleCanvasMouseDown(fakeEvent);
            }
        }

        function handleCanvasTouchMove(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const fakeEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                handleCanvasMouseMove(fakeEvent);
                e.preventDefault();
            }
        }

        function handleCanvasTouchEnd(e) {
            const touch = e.changedTouches[0];
            const fakeEvent = {
                target: document.elementFromPoint(touch.clientX, touch.clientY),
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            handleCanvasMouseUp(fakeEvent);
        }

        function handleCanvasDoubleClick(e) {
            const node = e.target.closest('.dag-node');
            if (node) {
                selectedNodeId = node.dataset.nodeId;
                openDagConfigPanel();
            }
        }

        function wouldCreateCycle(fromId, toId) {
            // DFS to check if adding edge from->to would create cycle
            const visited = new Set();

            function dfs(nodeId) {
                if (nodeId === fromId) return true;
                if (visited.has(nodeId)) return false;
                visited.add(nodeId);

                for (const edge of Object.values(dag.edges)) {
                    if (edge.from === nodeId) {
                        if (dfs(edge.to)) return true;
                    }
                }
                return false;
            }

            return dfs(toId);
        }

        function deleteEdge(edgeId) {
            if (confirm('Delete this connection?')) {
                saveDagSnapshot();  // Save for undo
                delete dag.edges[edgeId];
                saveToStorage();
                renderDag();
            }
        }

        function openDagConfigPanel() {
            if (!selectedNodeId) return;

            const node = dag.nodes[selectedNodeId];
            if (!node) return;

            // Populate model select
            const modelSelect = document.getElementById('node-model-select');
            modelSelect.innerHTML = models.map((m, i) =>
                `<option value="${i}" ${i === node.modelIndex ? 'selected' : ''}>${escapeHtml(m.name)}</option>`
            ).join('');

            // Populate prompt select
            const promptSelect = document.getElementById('node-prompt-select');
            promptSelect.innerHTML = '<option value="">Inherit from DAG</option>' +
                systemPrompts.map(p =>
                    `<option value="${p.id}" ${p.id === node.systemPrompt ? 'selected' : ''}>${escapeHtml(p.name)}</option>`
                ).join('');

            document.getElementById('node-custom-prompt').value = node.customPrompt || '';
            document.getElementById('node-context-mode').value = node.config.contextMode;
            document.getElementById('node-strip-reasoning').checked = node.config.stripReasoning;
            document.getElementById('node-is-terminal').checked = node.id === dag.terminalNode;

            document.getElementById('dag-config-panel').classList.add('open');
        }

        function closeDagConfigPanel() {
            document.getElementById('dag-config-panel').classList.remove('open');
        }

        function saveNodeConfig() {
            if (!selectedNodeId) return;

            const node = dag.nodes[selectedNodeId];
            if (!node) return;

            node.modelIndex = parseInt(document.getElementById('node-model-select').value);
            node.systemPrompt = document.getElementById('node-prompt-select').value || null;
            node.customPrompt = document.getElementById('node-custom-prompt').value;
            node.config.contextMode = document.getElementById('node-context-mode').value;
            node.config.stripReasoning = document.getElementById('node-strip-reasoning').checked;

            if (document.getElementById('node-is-terminal').checked) {
                dag.terminalNode = selectedNodeId;
            } else if (dag.terminalNode === selectedNodeId) {
                dag.terminalNode = null;
            }

            saveToStorage();
            closeDagConfigPanel();
            renderDag();
        }

        function deleteSelectedNode() {
            if (!selectedNodeId) return;

            if (confirm('Delete this node and its connections?')) {
                saveDagSnapshot();  // Save for undo

                // Remove edges connected to this node
                for (const edgeId of Object.keys(dag.edges)) {
                    const edge = dag.edges[edgeId];
                    if (edge.from === selectedNodeId || edge.to === selectedNodeId) {
                        delete dag.edges[edgeId];
                    }
                }

                // Remove node
                delete dag.nodes[selectedNodeId];

                // Update terminal if needed
                if (dag.terminalNode === selectedNodeId) {
                    const remaining = Object.keys(dag.nodes);
                    dag.terminalNode = remaining.length > 0 ? remaining[0] : null;
                }

                selectedNodeId = null;
                saveToStorage();
                closeDagConfigPanel();
                renderDag();
            }
        }

        function openDagSettings() {
            // Populate prompt select
            const promptSelect = document.getElementById('dag-global-prompt-select');
            promptSelect.innerHTML = '<option value="">None</option>' +
                systemPrompts.map(p =>
                    `<option value="${p.id}" ${p.id === dag.globalSystemPrompt ? 'selected' : ''}>${escapeHtml(p.name)}</option>`
                ).join('');

            document.getElementById('dag-custom-prompt').value = dag.globalCustomPrompt || '';
            document.getElementById('dag-history-limit').value = dag.settings?.historyLimit || 0;
            document.getElementById('dag-response-delay').value = dag.settings?.responseDelay || 500;
            document.getElementById('dag-include-files').checked = dag.settings?.includeFiles || false;
            document.getElementById('dag-model-identity').checked = dag.settings?.modelIdentity !== false;

            document.getElementById('dag-settings-panel').classList.add('open');
        }

        function closeDagSettingsPanel() {
            document.getElementById('dag-settings-panel').classList.remove('open');
        }

        function saveDagSettings() {
            dag.globalSystemPrompt = document.getElementById('dag-global-prompt-select').value || null;
            dag.globalCustomPrompt = document.getElementById('dag-custom-prompt').value;
            dag.settings = {
                historyLimit: parseInt(document.getElementById('dag-history-limit').value) || 0,
                responseDelay: parseInt(document.getElementById('dag-response-delay').value) || 500,
                includeFiles: document.getElementById('dag-include-files').checked,
                modelIdentity: document.getElementById('dag-model-identity').checked
            };

            saveToStorage();
            closeDagSettingsPanel();
        }

        function toggleDagRotation() {
            dag.rotation = dag.rotation || { enabled: false, index: 0 };
            dag.rotation.enabled = document.getElementById('dag-rotation-toggle').checked;
            saveToStorage();
        }

        function clearDag() {
            if (confirm('Clear the entire DAG?')) {
                saveDagSnapshot();  // Save for undo
                dag.nodes = {};
                dag.edges = {};
                dag.terminalNode = null;
                selectedNodeId = null;
                saveToStorage();
                renderDag();
            }
        }

        // ==================== DAG VIEW (Zoom/Pan) ====================

        let dagView = {
            zoom: 1,
            panX: 0,
            panY: 0
        };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let lastPinchDistance = 0;

        function updateDagTransform() {
            const wrapper = document.getElementById('dag-canvas-wrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${dagView.panX}px, ${dagView.panY}px) scale(${dagView.zoom})`;
            }
            document.getElementById('dag-zoom-level').textContent = Math.round(dagView.zoom * 100) + '%';
        }

        function zoomDag(delta, centerX, centerY) {
            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();

            // Default center to container center
            if (centerX === undefined) centerX = rect.width / 2;
            if (centerY === undefined) centerY = rect.height / 2;

            const oldZoom = dagView.zoom;
            dagView.zoom = Math.max(0.25, Math.min(3, dagView.zoom + delta));

            // Adjust pan to zoom towards the center point
            const zoomRatio = dagView.zoom / oldZoom;
            dagView.panX = centerX - (centerX - dagView.panX) * zoomRatio;
            dagView.panY = centerY - (centerY - dagView.panY) * zoomRatio;

            updateDagTransform();
        }

        function resetDagView() {
            dagView = { zoom: 1, panX: 0, panY: 0 };
            updateDagTransform();
        }

        function fitDagToView() {
            const nodes = Object.values(dag.nodes);
            if (nodes.length === 0) {
                resetDagView();
                return;
            }

            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();

            // Find bounding box of all nodes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const node of nodes) {
                minX = Math.min(minX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxX = Math.max(maxX, node.position.x + 120); // node width
                maxY = Math.max(maxY, node.position.y + 80);  // node height
            }

            const padding = 60;
            const contentWidth = maxX - minX + padding * 2;
            const contentHeight = maxY - minY + padding * 2;

            // Calculate zoom to fit
            const zoomX = rect.width / contentWidth;
            const zoomY = rect.height / contentHeight;
            dagView.zoom = Math.min(1.5, Math.max(0.25, Math.min(zoomX, zoomY)));

            // Center the content
            const scaledWidth = contentWidth * dagView.zoom;
            const scaledHeight = contentHeight * dagView.zoom;
            dagView.panX = (rect.width - scaledWidth) / 2 - (minX - padding) * dagView.zoom;
            dagView.panY = (rect.height - scaledHeight) / 2 - (minY - padding) * dagView.zoom;

            updateDagTransform();
        }

        function handleDagWheel(e) {
            if (e.target.closest('.dag-zoom-controls')) return;

            e.preventDefault();
            const rect = e.currentTarget.getBoundingClientRect();
            const centerX = e.clientX - rect.left;
            const centerY = e.clientY - rect.top;

            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoomDag(delta, centerX, centerY);
        }

        function startPanning(e) {
            // Only pan with middle mouse button or when holding space
            if (e.button === 1) {
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX - dagView.panX, y: e.clientY - dagView.panY };
                document.getElementById('dag-canvas-container').classList.add('panning');
            }
        }

        function handlePanning(e) {
            if (isPanning) {
                dagView.panX = e.clientX - panStart.x;
                dagView.panY = e.clientY - panStart.y;
                updateDagTransform();
            }
        }

        function stopPanning() {
            if (isPanning) {
                isPanning = false;
                document.getElementById('dag-canvas-container').classList.remove('panning');
            }
        }

        // Touch pinch-to-zoom and two-finger pan
        function handleDagTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                lastPinchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                panStart = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2 - dagView.panX,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2 - dagView.panY
                };
            }
        }

        function handleDagTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const newDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );

                // Pinch zoom
                const delta = (newDistance - lastPinchDistance) * 0.005;
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const rect = e.currentTarget.getBoundingClientRect();
                zoomDag(delta, centerX - rect.left, centerY - rect.top);

                lastPinchDistance = newDistance;

                // Two-finger pan
                dagView.panX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - panStart.x;
                dagView.panY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - panStart.y;
                updateDagTransform();
            }
        }

        // ==================== DAG HELP ====================

        function openDagHelp() {
            document.getElementById('dag-help-overlay').classList.add('open');
        }

        function closeDagHelp() {
            document.getElementById('dag-help-overlay').classList.remove('open');
        }

        // ==================== DAG AUTO-LAYOUT ====================

        function autoLayoutDag() {
            const nodes = Object.values(dag.nodes);
            if (nodes.length === 0) return;

            saveDagSnapshot();  // Save for undo

            // Build adjacency lists
            const inDegree = {};
            const outEdges = {};
            for (const node of nodes) {
                inDegree[node.id] = 0;
                outEdges[node.id] = [];
            }
            for (const edge of Object.values(dag.edges)) {
                inDegree[edge.to] = (inDegree[edge.to] || 0) + 1;
                outEdges[edge.from] = outEdges[edge.from] || [];
                outEdges[edge.from].push(edge.to);
            }

            // Topological sort to determine layers
            const layers = [];
            const nodeLayer = {};
            const queue = nodes.filter(n => inDegree[n.id] === 0).map(n => n.id);

            if (queue.length === 0 && nodes.length > 0) {
                // No root nodes - just spread them out
                const spacing = 150;
                nodes.forEach((node, i) => {
                    node.position.x = (i % 4) * spacing + 50;
                    node.position.y = Math.floor(i / 4) * 100 + 50;
                });
                saveToStorage();
                renderDag();
                fitDagToView();
                return;
            }

            while (queue.length > 0) {
                const currentLayer = [...queue];
                layers.push(currentLayer);
                queue.length = 0;

                for (const nodeId of currentLayer) {
                    nodeLayer[nodeId] = layers.length - 1;
                    for (const nextId of (outEdges[nodeId] || [])) {
                        inDegree[nextId]--;
                        if (inDegree[nextId] === 0) {
                            queue.push(nextId);
                        }
                    }
                }
            }

            // Position nodes by layer
            const containerRect = document.getElementById('dag-canvas-container').getBoundingClientRect();
            const nodeWidth = 140;
            const nodeHeight = 100;
            const layerGap = 120;

            const totalHeight = layers.length * layerGap;
            const startY = Math.max(50, (containerRect.height - totalHeight) / 2);

            for (let layer = 0; layer < layers.length; layer++) {
                const nodesInLayer = layers[layer];
                const totalWidth = nodesInLayer.length * nodeWidth;
                const startX = Math.max(50, (containerRect.width - totalWidth) / 2);

                nodesInLayer.forEach((nodeId, idx) => {
                    const node = dag.nodes[nodeId];
                    if (node) {
                        node.position.x = startX + idx * nodeWidth;
                        node.position.y = startY + layer * layerGap;
                    }
                });
            }

            saveToStorage();
            renderDag();
            fitDagToView();
            toastSuccess('Auto-layout applied');
        }

        // ==================== DAG TEMPLATES (Data-Driven) ====================

        // Template definitions - easy to extend and share
        const DAG_TEMPLATES = {
            single: {
                name: 'Single Model',
                description: 'A single model node',
                nodes: [
                    { name: 'A', x: 0, y: 0, terminal: true }
                ],
                edges: []
            },
            chain: {
                name: 'Chain (A→B→C)',
                description: 'Sequential processing through multiple models',
                nodes: [
                    { name: 'A', x: 0, y: -100 },
                    { name: 'B', x: 0, y: 0 },
                    { name: 'C', x: 0, y: 100, terminal: true }
                ],
                edges: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 }
                ]
            },
            parallel: {
                name: 'Parallel',
                description: 'Two models processing the same input',
                nodes: [
                    { name: 'Model 1', x: -90, y: 0, terminal: true },
                    { name: 'Model 2', x: 90, y: 0, terminal: true }
                ],
                edges: []
            },
            diamond: {
                name: 'Diamond',
                description: 'Split input, parallel processing, merge results',
                nodes: [
                    { name: 'Input', x: 0, y: -100 },
                    { name: 'Path A', x: -90, y: 0 },
                    { name: 'Path B', x: 90, y: 0 },
                    { name: 'Merge', x: 0, y: 100, terminal: true }
                ],
                edges: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 1, to: 3 },
                    { from: 2, to: 3 }
                ]
            },
            debate: {
                name: 'Debate',
                description: 'Two models debate, third judges',
                nodes: [
                    { name: 'Debater A', x: -90, y: -65 },
                    { name: 'Debater B', x: 90, y: -65 },
                    { name: 'Judge', x: 0, y: 65, terminal: true }
                ],
                edges: [
                    { from: 0, to: 2 },
                    { from: 1, to: 2 }
                ]
            },
            critic: {
                name: 'Critic Loop',
                description: 'Draft → Critique → Refine',
                nodes: [
                    { name: 'Draft', x: 0, y: -100 },
                    { name: 'Critic', x: 0, y: 0 },
                    { name: 'Refine', x: 0, y: 100, terminal: true }
                ],
                edges: [
                    { from: 0, to: 1 },
                    { from: 1, to: 2 }
                ]
            },
            ensemble: {
                name: 'Ensemble (3-way)',
                description: 'Three models with a synthesizer',
                nodes: [
                    { name: 'Model A', x: -120, y: -50 },
                    { name: 'Model B', x: 0, y: -50 },
                    { name: 'Model C', x: 120, y: -50 },
                    { name: 'Synthesizer', x: 0, y: 80, terminal: true }
                ],
                edges: [
                    { from: 0, to: 3 },
                    { from: 1, to: 3 },
                    { from: 2, to: 3 }
                ]
            }
        };

        function loadDagTemplate(templateKey) {
            if (!templateKey) return;

            const template = DAG_TEMPLATES[templateKey];
            if (!template) {
                toastError(`Unknown template: ${templateKey}`);
                return;
            }

            if (Object.keys(dag.nodes).length > 0) {
                if (!confirm(`Load "${template.name}" template? This will replace your current DAG.`)) {
                    document.getElementById('dag-template-select').value = '';
                    return;
                }
            }

            // Save current state for undo
            saveDagSnapshot();

            dag.nodes = {};
            dag.edges = {};
            dag.terminalNode = null;

            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            // Create nodes and track their IDs
            const nodeIds = [];
            for (const nodeDef of template.nodes) {
                const id = generateId();
                dag.nodes[id] = {
                    id: id,
                    modelIndex: 0,
                    position: {
                        x: centerX + nodeDef.x - 60,
                        y: centerY + nodeDef.y - 40
                    },
                    systemPrompt: null,
                    customPrompt: '',
                    config: {
                        contextMode: 'inputs-plus-user',
                        stripReasoning: false
                    }
                };

                if (nodeDef.terminal) {
                    dag.terminalNode = id;
                }

                nodeIds.push(id);
            }

            // Create edges using node indices
            for (const edgeDef of template.edges) {
                const edgeId = generateId();
                dag.edges[edgeId] = {
                    id: edgeId,
                    from: nodeIds[edgeDef.from],
                    to: nodeIds[edgeDef.to],
                    transform: 'full'
                };
            }

            document.getElementById('dag-template-select').value = '';
            saveToStorage();
            renderDag();
            toastSuccess(`Loaded "${template.name}" template`);
        }

        // Helper function to create a node (used for manual node creation too)
        function createTemplateNode(name, x, y, isTerminal = false) {
            const id = generateId();
            dag.nodes[id] = {
                id: id,
                modelIndex: 0,
                position: { x, y },
                systemPrompt: null,
                customPrompt: '',
                config: {
                    contextMode: 'inputs-plus-user',
                    stripReasoning: false
                }
            };

            if (isTerminal) {
                dag.terminalNode = id;
            }

            return id;
        }

        function createEdge(fromId, toId) {
            const id = generateId();
            dag.edges[id] = {
                id: id,
                from: fromId,
                to: toId,
                transform: 'full'
            };
        }

        // ==================== DAG EXECUTION ====================
        function topologicalSort() {
            const result = [];
            const visited = new Set();
            const temp = new Set();

            function visit(nodeId) {
                if (temp.has(nodeId)) {
                    throw new Error('Cycle detected in DAG');
                }
                if (visited.has(nodeId)) return;

                temp.add(nodeId);

                // Visit dependencies (nodes that feed into this one)
                for (const edge of Object.values(dag.edges)) {
                    if (edge.to === nodeId) {
                        visit(edge.from);
                    }
                }

                temp.delete(nodeId);
                visited.add(nodeId);
                result.push(nodeId);
            }

            for (const nodeId of Object.keys(dag.nodes)) {
                if (!visited.has(nodeId)) {
                    visit(nodeId);
                }
            }

            return result;
        }

        function getNodeInputs(nodeId, nodeOutputs) {
            const inputs = [];
            for (const edge of Object.values(dag.edges)) {
                if (edge.to === nodeId && nodeOutputs[edge.from]) {
                    let content = nodeOutputs[edge.from].forwarded;
                    inputs.push({
                        from: edge.from,
                        content: content,
                        transform: edge.transform
                    });
                }
            }
            return inputs;
        }

        function applyOutputTransform(node, fullOutput) {
            if (!node.config.stripReasoning) {
                return fullOutput;
            }

            // Strip thinking/reasoning patterns
            let stripped = fullOutput;
            // Remove <thinking>...</thinking> blocks
            stripped = stripped.replace(/<thinking>[\s\S]*?<\/thinking>/gi, '');
            // Remove [Thinking: ...] blocks
            stripped = stripped.replace(/\[Thinking:[\s\S]*?\]/gi, '');
            // Remove lines starting with common reasoning prefixes
            stripped = stripped.replace(/^(Let me think|I need to|First,|Hmm,|So,).*$/gim, '');
            return stripped.trim();
        }

        async function executeDAG(userMessage) {
            const nodeCount = Object.keys(dag.nodes).length;
            if (nodeCount === 0) {
                throw new Error('No nodes in DAG. Add at least one node.');
            }

            if (!dag.terminalNode) {
                throw new Error('No terminal node set. Double-click a node and set it as terminal.');
            }

            // Create execution record
            const execution = {
                id: generateId(),
                userMessage: userMessage,
                nodeOutputs: {},
                timestamp: new Date().toISOString()
            };

            // Get topological order
            let executionOrder;
            try {
                executionOrder = topologicalSort();
            } catch (e) {
                throw new Error('Invalid DAG: ' + e.message);
            }

            // Apply rotation if enabled
            if (dag.rotation?.enabled && executionOrder.length > 1) {
                const rotateBy = dag.rotation.index % executionOrder.length;
                for (let i = 0; i < rotateBy; i++) {
                    executionOrder.push(executionOrder.shift());
                }
                dag.rotation.index++;
                saveToStorage();
            }

            // Create placeholder message for DAG execution display
            const dagMessage = {
                role: 'assistant',
                isDagExecution: true,
                executionId: execution.id,
                nodeOutputs: {},
                nodeStatus: {},
                timestamp: new Date().toISOString()
            };

            // Initialize node status
            for (const nodeId of executionOrder) {
                dagMessage.nodeStatus[nodeId] = 'waiting';
                dagMessage.nodeOutputs[nodeId] = { full: '', forwarded: '', thinking: '' };
            }

            currentConversation.push(dagMessage);
            renderConversation();

            // Execute nodes in order
            for (const nodeId of executionOrder) {
                if (userStoppedGeneration) break;

                const node = dag.nodes[nodeId];
                if (!node) continue;

                dagMessage.nodeStatus[nodeId] = 'streaming';
                renderConversation();

                try {
                    // Get inputs from upstream nodes
                    const inputs = getNodeInputs(nodeId, dagMessage.nodeOutputs);

                    // Build context based on node config
                    const context = buildNodeContext(node, inputs, userMessage);

                    // Stream response
                    const model = models[node.modelIndex];
                    if (!model) {
                        throw new Error(`Model not found for node`);
                    }

                    const output = await streamNodeResponse(model, node, context, dagMessage, nodeId);

                    dagMessage.nodeOutputs[nodeId] = {
                        full: output.content,
                        forwarded: applyOutputTransform(node, output.content),
                        thinking: output.thinking || ''
                    };

                    dagMessage.nodeStatus[nodeId] = nodeId === dag.terminalNode ? 'terminal' : 'complete';

                } catch (error) {
                    dagMessage.nodeOutputs[nodeId] = {
                        full: `Error: ${error.message}`,
                        forwarded: `Error: ${error.message}`,
                        thinking: ''
                    };
                    dagMessage.nodeStatus[nodeId] = 'complete';
                }

                renderConversation();

                // Add delay between nodes
                if (dag.settings?.responseDelay > 0 && nodeId !== executionOrder[executionOrder.length - 1]) {
                    await new Promise(r => setTimeout(r, dag.settings.responseDelay));
                }
            }

            return dagMessage;
        }

        function buildNodeContext(node, inputs, userMessage) {
            const messages = [];

            switch (node.config.contextMode) {
                case 'inputs-only':
                    // Only include inputs from upstream nodes
                    if (inputs.length > 0) {
                        const inputText = inputs.map(i => {
                            const fromNode = dag.nodes[i.from];
                            const fromModel = models[fromNode?.modelIndex];
                            return `[From ${fromModel?.name || 'Unknown'}]:\n${i.content}`;
                        }).join('\n\n');
                        messages.push({ role: 'user', content: inputText });
                    } else {
                        messages.push({ role: 'user', content: userMessage });
                    }
                    break;

                case 'inputs-plus-user':
                    // Include user message plus inputs
                    let content = userMessage;
                    if (inputs.length > 0) {
                        content += '\n\n--- Previous Analysis ---\n';
                        content += inputs.map(i => {
                            const fromNode = dag.nodes[i.from];
                            const fromModel = models[fromNode?.modelIndex];
                            return `[${fromModel?.name || 'Unknown'}]:\n${i.content}`;
                        }).join('\n\n');
                    }
                    messages.push({ role: 'user', content: content });
                    break;

                case 'full-history':
                    // Include full conversation history
                    let historyLimit = dag.settings?.historyLimit || 0;
                    let historyMessages = currentConversation.filter(m => !m.isDagExecution);

                    if (historyLimit > 0) {
                        historyMessages = historyMessages.slice(-historyLimit);
                    }

                    for (const msg of historyMessages) {
                        if (msg.role === 'user') {
                            messages.push({ role: 'user', content: msg.content });
                        } else if (msg.role === 'assistant' && msg.content) {
                            messages.push({ role: 'assistant', content: msg.content });
                        }
                    }

                    // Add current user message with inputs
                    let fullContent = userMessage;
                    if (inputs.length > 0) {
                        fullContent += '\n\n--- Current Turn Analysis ---\n';
                        fullContent += inputs.map(i => {
                            const fromNode = dag.nodes[i.from];
                            const fromModel = models[fromNode?.modelIndex];
                            return `[${fromModel?.name || 'Unknown'}]:\n${i.content}`;
                        }).join('\n\n');
                    }
                    messages.push({ role: 'user', content: fullContent });
                    break;
            }

            return messages;
        }

        function buildNodeSystemPrompt(node) {
            let prompt = '';

            // Node-specific prompt takes precedence
            if (node.customPrompt) {
                prompt = node.customPrompt;
            } else if (node.systemPrompt) {
                const p = systemPrompts.find(sp => sp.id === node.systemPrompt);
                if (p) prompt = p.content;
            } else if (dag.globalCustomPrompt) {
                prompt = dag.globalCustomPrompt;
            } else if (dag.globalSystemPrompt) {
                const p = systemPrompts.find(sp => sp.id === dag.globalSystemPrompt);
                if (p) prompt = p.content;
            }

            // Add model identity if enabled
            if (dag.settings?.modelIdentity) {
                const model = models[node.modelIndex];
                if (model?.name) {
                    const identity = `You are ${model.name}. `;
                    prompt = identity + prompt;
                }
            }

            return prompt;
        }

        async function streamNodeResponse(model, node, messages, dagMessage, nodeId) {
            const body = {
                model: model.model_id,
                messages: messages,
                stream: true,
                modalities: ["text", "image"]
            };

            // Add optional parameters
            if (model.max_tokens) body.max_tokens = model.max_tokens;
            if (model.temperature !== undefined && model.temperature !== null) body.temperature = model.temperature;
            if (enableExtendedThinking) body.reasoning = { effort: thinkingEffort };

            // Add system prompt
            const systemPrompt = buildNodeSystemPrompt(node);
            if (systemPrompt) {
                body.messages.unshift({ role: 'system', content: systemPrompt });
            }

            const apiKey = resolveApiKey(model);
            if (!apiKey) {
                throw new Error('API key not configured');
            }

            const controller = new AbortController();
            currentAbortControllers.push(controller);

            const response = await fetch(model.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'HTTP-Referer': window.location.href,
                    'X-Title': 'DAGchat'
                },
                body: JSON.stringify(body),
                signal: controller.signal
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error ${response.status}: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let content = '';
            let thinking = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);

                            if (parsed.error) {
                                throw new Error(parsed.error.message || 'API error');
                            }

                            const delta = parsed.choices?.[0]?.delta;

                            if (delta?.content) {
                                if (typeof delta.content === 'string') {
                                    content += delta.content;
                                }
                            }

                            if (delta?.reasoning) {
                                thinking += delta.reasoning;
                            }

                            // Update display
                            dagMessage.nodeOutputs[nodeId] = {
                                full: content,
                                forwarded: applyOutputTransform(node, content),
                                thinking: thinking
                            };
                            scheduleRender();

                        } catch (e) {
                            if (e.message !== 'API error') {
                                console.error('Parse error:', e);
                            } else {
                                throw e;
                            }
                        }
                    }
                }
            }

            return { content, thinking };
        }

        // ==================== MESSAGE HANDLING ====================
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();

            if (!message && attachedFiles.length === 0) return;
            if (isStreaming) return;

            // Check if DAG is configured
            if (Object.keys(dag.nodes).length === 0) {
                toastWarning('Please configure at least one node in the DAG tab first.');
                switchTab('dag');
                return;
            }

            // Handle edit mode
            if (editingMessageIndex !== null) {
                currentConversation = currentConversation.slice(0, editingMessageIndex);
                editingMessageIndex = null;
                showEditIndicator(false);
            }

            // Create user message
            const userMessage = {
                role: 'user',
                content: message,
                files: attachedFiles.length > 0 ? [...attachedFiles] : undefined,
                timestamp: new Date().toISOString()
            };

            currentConversation.push(userMessage);
            input.value = '';
            attachedFiles = [];
            renderAttachedFiles();
            renderConversation();

            // Execute DAG
            isStreaming = true;
            userStoppedGeneration = false;
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();

            try {
                await executeDAG(message);
            } catch (error) {
                console.error('DAG execution error:', error);
                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
            }

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        function showStopButton() {
            document.getElementById('send-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'block';
        }

        function hideStopButton() {
            document.getElementById('send-btn').style.display = 'block';
            document.getElementById('stop-btn').style.display = 'none';
        }

        function stopGeneration() {
            userStoppedGeneration = true;
            for (const controller of currentAbortControllers) {
                try {
                    controller.abort();
                } catch (e) {}
            }
            currentAbortControllers = [];
            isStreaming = false;
            hideStopButton();
            stopBackgroundAudio();
        }

        // ==================== RENDERING ====================
        function scheduleRender() {
            if (renderTimer) return;
            renderTimer = requestAnimationFrame(() => {
                renderTimer = null;
                renderConversation();
            });
        }

        function renderConversation() {
            const container = document.getElementById('chat-messages');
            container.innerHTML = '';

            currentConversation.forEach((msg, index) => {
                if (msg.role === 'user') {
                    renderUserMessage(container, msg, index);
                } else if (msg.isDagExecution) {
                    renderDagExecution(container, msg, index);
                } else if (msg.role === 'assistant') {
                    renderAssistantMessage(container, msg, index);
                }
            });

            container.scrollTop = container.scrollHeight;
        }

        function renderUserMessage(container, msg, index) {
            const div = document.createElement('div');
            div.className = 'message user';

            let html = `<div class="message-content">${escapeHtml(msg.content)}</div>`;

            if (msg.files) {
                for (const file of msg.files) {
                    if (file.type?.startsWith('image/')) {
                        html += `<div class="file-preview"><img src="data:${file.type};base64,${file.base64}" alt="${escapeHtml(file.name)}"></div>`;
                    } else if (file.extractedText) {
                        html += `<div class="file-info">📄 ${escapeHtml(file.name)} - Text extracted</div>`;
                    } else {
                        html += `<div class="file-info">📎 ${escapeHtml(file.name)}</div>`;
                    }
                }
            }

            html += `<div class="message-actions">
                <button onclick="editMessage(${index})">Edit</button>
                <button onclick="regenerateFromMessage(${index})">Regenerate</button>
            </div>`;

            div.innerHTML = html;
            container.appendChild(div);
        }

        function renderDagExecution(container, msg, index) {
            const div = document.createElement('div');
            div.className = 'message dag-execution';

            let html = '<div style="font-size: 12px; color: #888; margin-bottom: 8px;">DAG Execution</div>';

            // Get topological order for display
            let displayOrder;
            try {
                displayOrder = topologicalSort();
            } catch (e) {
                displayOrder = Object.keys(msg.nodeOutputs || {});
            }

            for (const nodeId of displayOrder) {
                const node = dag.nodes[nodeId];
                const model = models[node?.modelIndex];
                const output = msg.nodeOutputs?.[nodeId];
                const status = msg.nodeStatus?.[nodeId] || 'waiting';
                const isTerminal = nodeId === dag.terminalNode;
                const isCollapsed = msg.collapsedNodes?.[nodeId] ?? !isTerminal;

                html += `<div class="dag-node-output">
                    <div class="dag-node-header" onclick="toggleDagNodeOutput(${index}, '${nodeId}')">
                        <span class="node-name">${escapeHtml(model?.name || 'Unknown')} ${isTerminal ? '★' : ''}</span>
                        <span class="node-status ${status}">${status}</span>
                    </div>
                    <div class="dag-node-content ${isCollapsed ? 'collapsed' : ''} ${node?.config?.stripReasoning && !isTerminal ? 'stripped' : ''}" id="dag-output-${index}-${nodeId}">`;

                if (output?.thinking) {
                    const thinkingId = `thinking-${index}-${nodeId}`;
                    html += `<div class="thinking-toggle" onclick="event.stopPropagation(); toggleThinking('${thinkingId}')">Chain of Thought</div>
                        <div id="${thinkingId}" class="thinking-content collapsed">${escapeHtml(output.thinking)}</div>`;
                }

                const content = isTerminal ? output?.full : output?.forwarded;
                html += `${renderMarkdownWithLatex(content || '')}
                    </div>
                </div>`;
            }

            div.innerHTML = html;
            container.appendChild(div);
        }

        function renderAssistantMessage(container, msg, index) {
            const div = document.createElement('div');
            div.className = 'message assistant';

            let html = '';
            if (msg.modelName) {
                html += `<div style="font-size: 12px; color: #888; margin-bottom: 8px;">${escapeHtml(msg.modelName)}</div>`;
            }

            if (msg.thinking) {
                const thinkingId = `thinking-${index}`;
                html += `<div class="thinking-toggle" onclick="toggleThinking('${thinkingId}')">Chain of Thought</div>
                    <div id="${thinkingId}" class="thinking-content collapsed">${escapeHtml(msg.thinking)}</div>`;
            }

            html += `<div class="message-content">${renderMarkdownWithLatex(msg.content || '')}</div>`;

            if (msg.images) {
                for (const img of msg.images) {
                    html += `<div class="file-preview"><img src="${escapeHtml(img.url)}" alt="Generated image"></div>`;
                }
            }

            html += `<div class="message-actions">
                <button onclick="editAssistantMessage(${index})">Edit</button>
                <button onclick="regenerateResponse(${index})">Regenerate</button>
            </div>`;

            div.innerHTML = html;
            container.appendChild(div);
        }

        function toggleDagNodeOutput(msgIndex, nodeId) {
            const msg = currentConversation[msgIndex];
            if (!msg) return;

            msg.collapsedNodes = msg.collapsedNodes || {};
            msg.collapsedNodes[nodeId] = !msg.collapsedNodes[nodeId];

            const element = document.getElementById(`dag-output-${msgIndex}-${nodeId}`);
            if (element) {
                element.classList.toggle('collapsed');
            }
        }

        function toggleThinking(thinkingId) {
            const element = document.getElementById(thinkingId);
            if (element) {
                element.classList.toggle('collapsed');
            }
        }

        // ==================== FILE HANDLING ====================
        async function handleFileUpload(e) {
            const files = Array.from(e.target.files);

            for (const file of files) {
                const fileData = {
                    name: file.name,
                    type: file.type,
                    size: file.size
                };

                if (file.type.startsWith('image/')) {
                    fileData.base64 = await fileToBase64(file);
                } else if (file.type === 'application/pdf') {
                    fileData.extractedText = await extractTextFromPDF(file);
                } else if (file.type.startsWith('text/') || isTextFile(file.name)) {
                    fileData.extractedText = await readTextFile(file);
                }

                attachedFiles.push(fileData);
            }

            renderAttachedFiles();
            e.target.value = '';
        }

        function isTextFile(filename) {
            const textExtensions = ['.txt', '.md', '.json', '.js', '.ts', '.py', '.html', '.css', '.xml', '.csv', '.yaml', '.yml'];
            return textExtensions.some(ext => filename.toLowerCase().endsWith(ext));
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function extractTextFromPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    text += content.items.map(item => item.str).join(' ') + '\n';
                }

                return text.trim();
            } catch (e) {
                console.error('PDF extraction error:', e);
                return '[Could not extract PDF text]';
            }
        }

        function readTextFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => resolve('[Could not read file]');
                reader.readAsText(file);
            });
        }

        function renderAttachedFiles() {
            const container = document.getElementById('attached-files');
            container.innerHTML = attachedFiles.map((file, i) => `
                <div class="attached-file">
                    <span>${escapeHtml(file.name)}</span>
                    <button onclick="removeAttachedFile(${i})">×</button>
                </div>
            `).join('');
        }

        function removeAttachedFile(index) {
            attachedFiles.splice(index, 1);
            renderAttachedFiles();
        }

        // ==================== EDIT/REGENERATE ====================
        function editMessage(index) {
            const msg = currentConversation[index];
            document.getElementById('message-input').value = msg.content;
            editingMessageIndex = index;
            showEditIndicator(true);

            if (msg.files) {
                attachedFiles = [...msg.files];
                renderAttachedFiles();
            }
        }

        function showEditIndicator(show) {
            const indicator = document.getElementById('edit-indicator');
            const input = document.getElementById('message-input');
            indicator.classList.toggle('visible', show);
            input.classList.toggle('editing', show);
        }

        function cancelEditMode() {
            editingMessageIndex = null;
            document.getElementById('message-input').value = '';
            attachedFiles = [];
            renderAttachedFiles();
            showEditIndicator(false);
        }

        function editAssistantMessage(index) {
            const msg = currentConversation[index];
            openEditModal('Edit Response', msg.content, (newContent) => {
                if (newContent !== null && newContent !== msg.content) {
                    msg.content = newContent;
                    currentConversation = currentConversation.slice(0, index + 1);
                    saveToStorage();
                    renderConversation();
                    toastSuccess('Response updated');
                }
            });
        }

        async function regenerateFromMessage(index) {
            if (isStreaming) return;

            currentConversation = currentConversation.slice(0, index + 1);
            renderConversation();

            const userMsg = currentConversation[index];
            if (userMsg.role !== 'user') return;

            isStreaming = true;
            userStoppedGeneration = false;
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();

            try {
                await executeDAG(userMsg.content);
            } catch (error) {
                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
            }

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        async function regenerateResponse(index) {
            // For non-DAG messages, just regenerate
            const msg = currentConversation[index];
            if (msg.isDagExecution) {
                // Find the user message before this
                for (let i = index - 1; i >= 0; i--) {
                    if (currentConversation[i].role === 'user') {
                        await regenerateFromMessage(i);
                        return;
                    }
                }
            }
        }

        // ==================== HISTORY ====================
        function renderHistory() {
            const list = document.getElementById('history-list');
            let html = '';

            if (currentConversation.length > 0) {
                const summary = currentConversation.slice(0, 2).map(msg => {
                    const content = msg.content || '';
                    return `${msg.role}: ${content.substring(0, 50)}...`;
                }).join('\n');

                html += `<div class="history-item">
                    <h4>Current Conversation</h4>
                    <div style="font-size: 13px; color: #aaa;">${escapeHtml(summary)}</div>
                    <div class="history-actions">
                        <button onclick="exportConversation()">Export</button>
                        <button onclick="clearConversation()">Clear</button>
                    </div>
                </div>`;
            }

            if (conversationHistory.length > 0) {
                html += '<h3 style="margin: 20px 0 12px; color: #4a9eff;">Saved</h3>';

                conversationHistory.forEach((entry, i) => {
                    const date = new Date(entry.timestamp).toLocaleString();
                    html += `<div class="history-item">
                        <h4>${escapeHtml(date)}</h4>
                        <div style="font-size: 12px; color: #888;">${entry.messageCount} messages</div>
                        <div class="history-actions">
                            <button onclick="loadConversation(${i})">Load</button>
                            <button onclick="deleteHistoryItem(${i})">Delete</button>
                        </div>
                    </div>`;
                });
            }

            list.innerHTML = html || '<p style="color: #888;">No history yet.</p>';
        }

        function newChat() {
            if (currentConversation.length > 0) {
                conversationHistory.unshift({
                    id: Date.now().toString(),
                    timestamp: new Date().toISOString(),
                    conversation: [...currentConversation],
                    messageCount: currentConversation.length
                });

                if (conversationHistory.length > 50) {
                    conversationHistory = conversationHistory.slice(0, 50);
                }
            }

            currentConversation = [];
            attachedFiles = [];
            editingMessageIndex = null;
            showEditIndicator(false);
            saveToStorage();
            renderConversation();
            renderHistory();
            renderAttachedFiles();
            document.getElementById('message-input').value = '';
        }

        function loadConversation(index) {
            if (!confirm('Load this conversation?')) return;
            currentConversation = [...conversationHistory[index].conversation];
            saveToStorage();
            renderConversation();
            switchTab('chat');
        }

        function deleteHistoryItem(index) {
            if (!confirm('Delete this conversation?')) return;
            conversationHistory.splice(index, 1);
            saveToStorage();
            renderHistory();
        }

        function clearConversation() {
            if (!confirm('Clear current conversation?')) return;
            currentConversation = [];
            saveToStorage();
            renderConversation();
            renderHistory();
        }

        function clearHistory() {
            if (!confirm('Clear ALL history?')) return;
            conversationHistory = [];
            currentConversation = [];
            saveToStorage();
            renderConversation();
            renderHistory();
        }

        function exportConversation() {
            downloadJSON({
                conversation: currentConversation,
                dag: dag,
                timestamp: new Date().toISOString()
            }, `dagchat-${Date.now()}.json`);
        }

        function importHistory(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.conversation) {
                        currentConversation = data.conversation;
                        if (data.dag) dag = data.dag;
                        saveToStorage();
                        renderConversation();
                        renderDag();
                        toastSuccess('Conversation imported!');
                        switchTab('chat');
                    }
                } catch (e) {
                    toastError(e.message, 'Import Failed');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ==================== SETTINGS ====================
        function addApiKey() {
            const name = document.getElementById('new-api-key-name').value.trim();
            const value = document.getElementById('new-api-key-value').value.trim();

            if (!name || !value) {
                toastWarning('Please enter both name and value');
                return;
            }

            apiKeys.push({
                id: generateId(),
                name: name,
                value: value
            });

            document.getElementById('new-api-key-name').value = '';
            document.getElementById('new-api-key-value').value = '';
            saveToStorage();
            updateApiKeysList();
        }

        function deleteApiKey(id) {
            apiKeys = apiKeys.filter(k => k.id !== id);
            saveToStorage();
            updateApiKeysList();
        }

        function updateApiKeysList() {
            const list = document.getElementById('api-keys-list');
            list.innerHTML = apiKeys.map(key => `
                <div class="api-key-item">
                    <h4>${escapeHtml(key.name)}</h4>
                    <div style="font-size: 12px; color: #888;">${key.value.substring(0, 10)}...</div>
                    <button onclick="deleteApiKey('${key.id}')" style="margin-top: 8px;">Delete</button>
                </div>
            `).join('');
        }

        function addSystemPrompt() {
            const name = document.getElementById('new-prompt-name').value.trim();
            const content = document.getElementById('new-prompt-content').value.trim();

            if (!name || !content) {
                toastWarning('Please enter both name and content');
                return;
            }

            systemPrompts.push({
                id: generateId(),
                name: name,
                content: content
            });

            document.getElementById('new-prompt-name').value = '';
            document.getElementById('new-prompt-content').value = '';
            saveToStorage();
            updatePromptsList();
        }

        function deletePrompt(id) {
            systemPrompts = systemPrompts.filter(p => p.id !== id);
            saveToStorage();
            updatePromptsList();
        }

        function updatePromptsList() {
            const list = document.getElementById('prompts-list');
            list.innerHTML = systemPrompts.map(prompt => `
                <div class="prompt-item">
                    <h4>${escapeHtml(prompt.name)}</h4>
                    <div style="font-size: 12px; color: #888;">${escapeHtml(prompt.content.substring(0, 100))}...</div>
                    <button onclick="deletePrompt('${prompt.id}')" style="margin-top: 8px;">Delete</button>
                </div>
            `).join('');
        }

        function addModel() {
            const name = document.getElementById('new-model-name').value.trim();
            const config = document.getElementById('new-model-config').value.trim();

            if (!name || !config) {
                toastWarning('Please enter both name and config');
                return;
            }

            try {
                const parsed = JSON.parse(config);
                parsed.name = name;
                models.push(parsed);

                document.getElementById('new-model-name').value = '';
                document.getElementById('new-model-config').value = '';
                saveToStorage();
                updateModelsList();
            } catch (e) {
                toastError(e.message, 'Invalid JSON');
            }
        }

        function deleteModel(index) {
            models.splice(index, 1);
            saveToStorage();
            updateModelsList();
        }

        function updateModelsList() {
            const list = document.getElementById('models-list');
            list.innerHTML = models.map((model, i) => `
                <div class="model-item">
                    <h4>${escapeHtml(model.name)}</h4>
                    <div style="font-size: 12px; color: #888;">${escapeHtml(model.model_id || 'No model ID')}</div>
                    <div class="model-actions">
                        <button onclick="editModel(${i})">Edit</button>
                        <button onclick="deleteModel(${i})">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function editModel(index) {
            const model = models[index];
            const name = model.name;
            const config = { ...model };
            delete config.name;

            document.getElementById('new-model-name').value = name;
            document.getElementById('new-model-config').value = JSON.stringify(config, null, 2);

            models.splice(index, 1);
            saveToStorage();
            updateModelsList();
        }

        async function fetchOpenRouterModels() {
            const browser = document.getElementById('models-browser');
            browser.style.display = 'block';
            browser.innerHTML = '<p>Loading models...</p>';

            try {
                const response = await fetch('https://openrouter.ai/api/v1/models');
                const data = await response.json();

                let html = '<input type="text" id="model-search" placeholder="Search models..." oninput="filterOpenRouterModels()" style="margin-bottom: 12px;">';
                html += '<div id="model-results">';

                data.data.sort((a, b) => (b.created || 0) - (a.created || 0)).slice(0, 100).forEach(model => {
                    html += `<div class="model-item" onclick="selectOpenRouterModel('${escapeHtml(model.id)}', '${escapeHtml(model.name || model.id)}')" style="cursor: pointer;">
                        <h4>${escapeHtml(model.name || model.id)}</h4>
                        <div style="font-size: 11px; color: #888;">${escapeHtml(model.id)}</div>
                    </div>`;
                });

                html += '</div>';
                browser.innerHTML = html;
                window.openRouterModels = data.data;
            } catch (e) {
                browser.innerHTML = `<p style="color: #ff6b6b;">Error loading models: ${e.message}</p>`;
            }
        }

        function filterOpenRouterModels() {
            const search = document.getElementById('model-search').value.toLowerCase();
            const results = document.getElementById('model-results');

            if (!window.openRouterModels) return;

            const filtered = window.openRouterModels.filter(m =>
                (m.name || '').toLowerCase().includes(search) ||
                m.id.toLowerCase().includes(search)
            ).slice(0, 50);

            results.innerHTML = filtered.map(model => `
                <div class="model-item" onclick="selectOpenRouterModel('${escapeHtml(model.id)}', '${escapeHtml(model.name || model.id)}')" style="cursor: pointer;">
                    <h4>${escapeHtml(model.name || model.id)}</h4>
                    <div style="font-size: 11px; color: #888;">${escapeHtml(model.id)}</div>
                </div>
            `).join('');
        }

        function selectOpenRouterModel(id, name) {
            document.getElementById('new-model-name').value = name;
            document.getElementById('new-model-config').value = JSON.stringify({
                endpoint: "https://openrouter.ai/api/v1/chat/completions",
                model_id: id,
                api_key_id: apiKeys.length > 0 ? apiKeys[0].id : "YOUR_API_KEY_ID"
            }, null, 2);

            document.getElementById('models-browser').style.display = 'none';
        }

        function saveUserIdentifier() {
            userIdentifier = document.getElementById('user-identifier-input').value || 'Human';
            saveToStorage();
        }

        function updateUserIdentifierInput() {
            document.getElementById('user-identifier-input').value = userIdentifier;
        }

        function toggleLatex() {
            enableLatexRendering = document.getElementById('latex-toggle').checked;
            if (enableLatexRendering) loadKaTeX();
            saveToStorage();
            renderConversation();
        }

        function toggleMarkdown() {
            enableMarkdownRendering = document.getElementById('markdown-toggle').checked;
            if (enableMarkdownRendering) loadSnarkdown();
            saveToStorage();
            renderConversation();
        }

        function toggleThinkingMode() {
            enableExtendedThinking = document.getElementById('thinking-toggle').checked;
            saveToStorage();
        }

        function toggleBackgroundAudio() {
            enableBackgroundAudio = document.getElementById('background-audio-toggle').checked;
            saveToStorage();
        }

        function resolveApiKey(model) {
            if (model.api_key_id) {
                const key = apiKeys.find(k => k.id === model.api_key_id);
                return key?.value;
            }
            return model.api_key;
        }

        function exportData() {
            downloadJSON({
                models,
                apiKeys,
                systemPrompts,
                dag,
                currentConversation,
                conversationHistory,
                userIdentifier,
                exportDate: new Date().toISOString()
            }, `dagchat-backup-${Date.now()}.json`);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.models) models = data.models;
                    if (data.apiKeys) apiKeys = data.apiKeys;
                    if (data.systemPrompts) systemPrompts = data.systemPrompts;
                    if (data.dag) dag = data.dag;
                    if (data.currentConversation) currentConversation = data.currentConversation;
                    if (data.conversationHistory) conversationHistory = data.conversationHistory;
                    if (data.userIdentifier) userIdentifier = data.userIdentifier;

                    await saveToStorage();
                    await init();
                    toastSuccess('All data imported!');
                } catch (e) {
                    toastError(e.message, 'Import Failed');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== UTILITIES ====================

        // Fast HTML escaping using regex instead of DOM manipulation
        const htmlEscapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };

        function escapeHtml(text) {
            if (!text) return '';
            return String(text).replace(/[&<>"']/g, char => htmlEscapeMap[char]);
        }

        // ==================== TOAST NOTIFICATIONS ====================
        function showToast(message, type = 'info', title = null, duration = null) {
            const container = document.getElementById('toast-container');
            if (!container) return;

            const icons = {
                success: '✓',
                error: '✕',
                warning: '⚠',
                info: 'ℹ'
            };

            const toastDuration = duration || (type === 'error' ? CONFIG.TOAST_ERROR_DURATION : CONFIG.TOAST_DURATION);

            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <div class="toast-content">
                    ${title ? `<div class="toast-title">${escapeHtml(title)}</div>` : ''}
                    <div class="toast-message">${escapeHtml(message)}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">×</button>
            `;

            container.appendChild(toast);

            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 300);
            }, toastDuration);

            return toast;
        }

        // Convenience functions
        function toastSuccess(message, title = null) {
            return showToast(message, 'success', title);
        }

        function toastError(message, title = 'Error') {
            return showToast(message, 'error', title);
        }

        function toastWarning(message, title = null) {
            return showToast(message, 'warning', title);
        }

        function toastInfo(message, title = null) {
            return showToast(message, 'info', title);
        }

        // ==================== EDIT MODAL ====================
        let editModalCallback = null;
        let editModalContext = null;

        function openEditModal(title, content, callback, context = null) {
            document.getElementById('edit-modal-title').textContent = title;
            document.getElementById('edit-modal-content').value = content || '';
            editModalCallback = callback;
            editModalContext = context;
            document.getElementById('edit-modal').classList.add('open');
            document.getElementById('edit-modal-content').focus();
        }

        function closeEditModal() {
            document.getElementById('edit-modal').classList.remove('open');
            editModalCallback = null;
            editModalContext = null;
        }

        function saveEditModal() {
            const content = document.getElementById('edit-modal-content').value;
            if (editModalCallback) {
                editModalCallback(content, editModalContext);
            }
            closeEditModal();
        }

        // Handle Escape key to close modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('edit-modal');
                if (modal.classList.contains('open')) {
                    closeEditModal();
                }
            }
        });

        // ==================== UNDO/REDO SYSTEM ====================
        const MAX_UNDO_HISTORY = 50;

        function saveDagSnapshot() {
            // Clone current DAG state
            const snapshot = JSON.parse(JSON.stringify(dag));

            // Truncate future history if we're not at the end
            if (state.dagHistoryIndex < state.dagHistory.length - 1) {
                state.dagHistory = state.dagHistory.slice(0, state.dagHistoryIndex + 1);
            }

            // Add new snapshot
            state.dagHistory.push(snapshot);

            // Limit history size
            if (state.dagHistory.length > MAX_UNDO_HISTORY) {
                state.dagHistory.shift();
            }

            state.dagHistoryIndex = state.dagHistory.length - 1;
        }

        function undoDag() {
            if (state.dagHistoryIndex <= 0) {
                toastInfo('Nothing to undo');
                return;
            }

            state.dagHistoryIndex--;
            const snapshot = state.dagHistory[state.dagHistoryIndex];
            Object.assign(dag, JSON.parse(JSON.stringify(snapshot)));
            saveToStorage();
            renderDag();
            toastInfo('Undo');
        }

        function redoDag() {
            if (state.dagHistoryIndex >= state.dagHistory.length - 1) {
                toastInfo('Nothing to redo');
                return;
            }

            state.dagHistoryIndex++;
            const snapshot = state.dagHistory[state.dagHistoryIndex];
            Object.assign(dag, JSON.parse(JSON.stringify(snapshot)));
            saveToStorage();
            renderDag();
            toastInfo('Redo');
        }

        // ==================== COPY/PASTE ====================
        function copySelectedNode() {
            if (!selectedNodeId) {
                toastWarning('No node selected');
                return;
            }

            const node = dag.nodes[selectedNodeId];
            if (!node) return;

            state.clipboard = {
                type: 'node',
                data: JSON.parse(JSON.stringify(node))
            };
            toastSuccess('Node copied');
        }

        function pasteNode() {
            if (!state.clipboard || state.clipboard.type !== 'node') {
                toastWarning('Nothing to paste');
                return;
            }

            saveDagSnapshot();

            const original = state.clipboard.data;
            const newId = generateId();
            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();

            dag.nodes[newId] = {
                ...JSON.parse(JSON.stringify(original)),
                id: newId,
                position: {
                    x: Math.min(original.position.x + 30, rect.width - CONFIG.NODE_WIDTH),
                    y: Math.min(original.position.y + 30, rect.height - CONFIG.NODE_HEIGHT)
                }
            };

            selectedNodeId = newId;
            saveToStorage();
            renderDag();
            toastSuccess('Node pasted');
        }

        // ==================== KEYBOARD SHORTCUTS ====================
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Only handle shortcuts when not in input fields
                const isInput = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);

                // Ctrl/Cmd + Z = Undo
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey && !isInput) {
                    e.preventDefault();
                    undoDag();
                }

                // Ctrl/Cmd + Shift + Z or Ctrl/Cmd + Y = Redo
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey)) && !isInput) {
                    e.preventDefault();
                    redoDag();
                }

                // Ctrl/Cmd + C = Copy (when in DAG tab)
                if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !isInput) {
                    const dagTab = document.getElementById('dag-tab');
                    if (dagTab.classList.contains('active') && selectedNodeId) {
                        e.preventDefault();
                        copySelectedNode();
                    }
                }

                // Ctrl/Cmd + V = Paste (when in DAG tab)
                if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !isInput) {
                    const dagTab = document.getElementById('dag-tab');
                    if (dagTab.classList.contains('active') && state.clipboard) {
                        e.preventDefault();
                        pasteNode();
                    }
                }

                // Delete or Backspace = Delete selected node (when in DAG tab)
                if ((e.key === 'Delete' || e.key === 'Backspace') && !isInput) {
                    const dagTab = document.getElementById('dag-tab');
                    if (dagTab.classList.contains('active') && selectedNodeId) {
                        e.preventDefault();
                        deleteSelectedNode();
                    }
                }

                // Escape = Close panels, deselect node, or close help
                if (e.key === 'Escape' && !isInput) {
                    // First close help overlay if open
                    const helpOverlay = document.getElementById('dag-help-overlay');
                    if (helpOverlay.classList.contains('open')) {
                        closeDagHelp();
                        return;
                    }

                    // Then deselect/close config panels
                    if (selectedNodeId) {
                        selectedNodeId = null;
                        closeDagConfigPanel();
                        renderDag();
                    }
                }
            });
        }

        // ==================== DAG EXPORT/IMPORT ====================
        function exportDag() {
            downloadJSON({
                dag: dag,
                exportDate: new Date().toISOString(),
                version: '1.0'
            }, `dag-${Date.now()}.json`);
            toastSuccess('DAG exported');
        }

        function importDag(event) {
            const file = event?.target?.files?.[0];
            if (!file) {
                // Trigger file input
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = importDag;
                input.click();
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.dag) {
                        throw new Error('Invalid DAG file');
                    }

                    saveDagSnapshot();
                    Object.assign(dag, data.dag);
                    saveToStorage();
                    renderDag();
                    toastSuccess('DAG imported');
                } catch (err) {
                    toastError(err.message, 'Import Failed');
                }
            };
            reader.readAsText(file);
            if (event?.target) event.target.value = '';
        }

        // Background audio for iOS
        function startBackgroundAudio() {
            if (!enableBackgroundAudio) return;
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                if (!silentAudioNode) {
                    silentAudioNode = audioContext.createOscillator();
                    silentAudioNode.frequency.value = 0;
                    const gain = audioContext.createGain();
                    gain.gain.value = 0;
                    silentAudioNode.connect(gain);
                    gain.connect(audioContext.destination);
                    silentAudioNode.start();
                }
            } catch (e) {
                console.error('Audio error:', e);
            }
        }

        function stopBackgroundAudio() {
            if (silentAudioNode) {
                try {
                    silentAudioNode.stop();
                } catch (e) {}
                silentAudioNode = null;
            }
        }

        // Lazy load KaTeX
        let katexLoaded = false;
        async function loadKaTeX() {
            if (katexLoaded) return;

            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
            document.head.appendChild(link);

            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });

            katexLoaded = true;
        }

        // Lazy load snarkdown
        let snarkdownLoaded = false;
        async function loadSnarkdown() {
            if (snarkdownLoaded) return;

            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/snarkdown@2.0.0/dist/snarkdown.umd.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });

            snarkdownLoaded = true;
        }

        function renderMarkdownWithLatex(text) {
            if (!text) return '';

            if (!enableLatexRendering && !enableMarkdownRendering) {
                return escapeHtml(text);
            }

            const masks = [];
            let processed = text;

            // Mask code blocks
            processed = processed.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                const id = masks.length;
                masks.push({ type: 'fenced', lang, code });
                return `\x00MASK${id}\x00`;
            });

            processed = processed.replace(/`([^`]+)`/g, (match, code) => {
                const id = masks.length;
                masks.push({ type: 'inline', code });
                return `\x00MASK${id}\x00`;
            });

            // Render LaTeX
            if (enableLatexRendering && typeof katex !== 'undefined') {
                processed = processed.replace(/\$\$([\s\S]+?)\$\$/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        masks.push({ type: 'latex', html: katex.renderToString(latex.trim(), { throwOnError: false, displayMode: true }) });
                    } catch (e) {
                        masks.push({ type: 'text', text: match });
                    }
                    return `\x00MASK${id}\x00`;
                });

                processed = processed.replace(/\$([^\$\n]+)\$/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        masks.push({ type: 'latex', html: katex.renderToString(latex.trim(), { throwOnError: false }) });
                    } catch (e) {
                        masks.push({ type: 'text', text: match });
                    }
                    return `\x00MASK${id}\x00`;
                });
            }

            // Escape remaining text
            processed = escapeHtml(processed);

            // Render markdown
            if (enableMarkdownRendering && typeof snarkdown !== 'undefined') {
                processed = snarkdown(processed);
            }

            // Restore masks
            processed = processed.replace(/\x00MASK(\d+)\x00/g, (match, i) => {
                const mask = masks[+i];
                if (!mask) return '';

                switch (mask.type) {
                    case 'fenced':
                        return `<pre style="background: #2a2a2a; padding: 12px; border-radius: 6px; overflow-x: auto;"><code>${escapeHtml(mask.code)}</code></pre>`;
                    case 'inline':
                        return `<code style="background: #3a3a3a; padding: 2px 6px; border-radius: 3px;">${escapeHtml(mask.code)}</code>`;
                    case 'latex':
                        return mask.html;
                    case 'text':
                        return escapeHtml(mask.text);
                    default:
                        return '';
                }
            });

            return processed;
        }

        // Initialize
        init();
    </script>
</body>
</html>

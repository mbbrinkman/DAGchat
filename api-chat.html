<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>DAGchat - Multi-Model DAG Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    </script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            padding: 0 12px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 16px;
            cursor: pointer;
            border: none;
            background: none;
            color: #888;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: #e0e0e0;
        }

        .tab.active {
            color: #e0e0e0;
            border-bottom-color: #4a9eff;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }

        .tab-content.active {
            display: flex;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .message {
            margin-bottom: 20px;
            max-width: 85%;
        }

        .message.user {
            margin-left: auto;
            background: #2a4a7a;
            padding: 12px 16px;
            border-radius: 12px;
        }

        .message.assistant {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
        }

        .message.dag-execution {
            background: #1e2a1e;
            border: 1px solid #3a5a3a;
            max-width: 100%;
        }

        .dag-node-output {
            background: #2a2a2a;
            border-radius: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .dag-node-header {
            background: #3a3a3a;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .dag-node-header:hover {
            background: #4a4a4a;
        }

        .dag-node-header .node-name {
            font-weight: 600;
            font-size: 13px;
        }

        .dag-node-header .node-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: #4a4a4a;
        }

        .dag-node-header .node-status.streaming {
            background: #4a9eff;
            color: white;
        }

        .dag-node-header .node-status.complete {
            background: #4a8a4a;
            color: white;
        }

        .dag-node-header .node-status.waiting {
            background: #6a6a4a;
            color: white;
        }

        .dag-node-header .node-status.terminal {
            background: #9a4aff;
            color: white;
        }

        .dag-node-content {
            padding: 12px;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .dag-node-content.collapsed {
            display: none;
        }

        .dag-node-content.stripped {
            color: #888;
            font-style: italic;
        }

        .thinking-toggle {
            background: #3a2a1a;
            border: 1px solid #4a4a4a;
            color: #ff8c42;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 8px 0;
            display: inline-block;
            user-select: none;
        }

        .thinking-toggle:hover {
            background: #4a3a2a;
        }

        .thinking-content {
            background: #3a2a1a;
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #ff8c42;
            margin: 8px 0;
            font-style: italic;
            font-size: 13px;
            color: #d0d0d0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .thinking-content.collapsed {
            display: none;
        }

        .typing-indicator {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 85%;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            opacity: 0.7;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-indicator .dot {
            width: 8px;
            height: 8px;
            background: #4a9eff;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .message-content ol,
        .message-content ul {
            white-space: normal;
            margin: 8px 0;
            padding-left: 24px;
        }

        .message-content ol {
            list-style-type: decimal;
        }

        .message-content ul {
            list-style-type: disc;
        }

        .message-content li {
            white-space: pre-wrap;
            margin: 4px 0;
        }

        .message-content a {
            color: #4a9eff;
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        .message-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .message-actions button {
            background: #3a3a3a;
            border: none;
            color: #888;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .message-actions button:hover {
            background: #4a4a4a;
            color: #e0e0e0;
        }

        .file-preview {
            margin-top: 8px;
            max-width: 100%;
        }

        .file-preview img, .file-preview video {
            max-width: 100%;
            border-radius: 8px;
        }

        .file-info {
            background: #3a3a3a;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 8px;
        }

        #chat-input-area {
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            padding: 16px;
        }

        .input-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-controls, .send-controls {
            display: flex;
            gap: 8px;
        }

        .input-controls {
            width: 100%;
        }

        .input-controls button {
            flex: 1;
        }

        .send-controls {
            width: 100%;
        }

        .send-controls button {
            flex: 1;
        }

        #message-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 44px;
            max-height: 200px;
        }

        #message-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        #message-input.editing {
            border-color: #f0ad4e;
        }

        #edit-indicator {
            display: none;
            color: #f0ad4e;
            font-size: 12px;
            margin-bottom: 4px;
            align-items: center;
            gap: 8px;
        }

        #edit-indicator.visible {
            display: flex;
        }

        #edit-indicator button {
            background: transparent;
            border: none;
            color: #888;
            padding: 0;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }

        #edit-indicator button:hover {
            color: #e0e0e0;
        }

        .file-upload-btn, .model-select, #send-btn {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .model-select {
            min-width: 120px;
        }

        #send-btn {
            background: #4a9eff;
            border-color: #4a9eff;
            font-weight: 600;
        }

        #send-btn:hover {
            background: #3a8eef;
        }

        #send-btn:disabled {
            background: #3a3a3a;
            color: #666;
            cursor: not-allowed;
        }

        #stop-btn {
            background: #ff6b6b;
            border-color: #ff6b6b;
            font-weight: 600;
            display: none;
        }

        #stop-btn:hover {
            background: #ff5252;
        }

        .attached-files {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .attached-file {
            background: #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .attached-file button {
            background: #4a4a4a;
            border: none;
            color: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        /* DAG Editor Styles */
        #dag-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #dag-toolbar {
            background: #2a2a2a;
            padding: 12px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        #dag-toolbar button, #dag-toolbar select {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }

        #dag-toolbar button:hover {
            background: #4a4a4a;
        }

        #dag-toolbar button.active {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        #dag-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
            background-image:
                radial-gradient(circle, #333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #dag-canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .dag-node {
            position: absolute;
            background: #2a2a2a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            min-width: 120px;
            cursor: move;
            user-select: none;
            touch-action: none;
        }

        .dag-node.selected {
            border-color: #4a9eff;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.3);
        }

        .dag-node.terminal {
            border-color: #9a4aff;
        }

        .dag-node-title {
            background: #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dag-node.terminal .dag-node-title {
            background: #4a3a5a;
        }

        .dag-node-body {
            padding: 8px 12px;
            font-size: 12px;
            color: #aaa;
        }

        .dag-node-ports {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px 8px;
        }

        .dag-port {
            width: 12px;
            height: 12px;
            background: #4a4a4a;
            border-radius: 50%;
            cursor: crosshair;
        }

        .dag-port.input {
            background: #4a9eff;
        }

        .dag-port.output {
            background: #4aff9e;
        }

        .dag-port:hover {
            transform: scale(1.3);
        }

        /* Settings styles */
        .settings-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .settings-section {
            background: #2a2a2a;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .settings-section h3 {
            margin-bottom: 12px;
            color: #4a9eff;
        }

        .settings-section input[type="text"],
        .settings-section input[type="number"],
        .settings-section textarea,
        .settings-section select {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 8px;
            font-family: inherit;
        }

        .settings-section textarea {
            min-height: 100px;
            resize: vertical;
        }

        .settings-section button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-section button:hover {
            background: #4a4a4a;
        }

        .settings-section button.primary {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .settings-section button.primary:hover {
            background: #3a8eef;
        }

        .settings-section button.danger {
            background: #ff4a4a;
            border-color: #ff4a4a;
        }

        .model-item, .api-key-item, .prompt-item {
            background: #3a3a3a;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .model-item h4, .api-key-item h4, .prompt-item h4 {
            margin-bottom: 4px;
        }

        .model-actions, .prompt-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .model-actions button, .prompt-actions button {
            padding: 4px 8px;
            font-size: 12px;
        }

        .history-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .history-item {
            background: #2a2a2a;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .history-item h4 {
            margin-bottom: 8px;
            color: #4a9eff;
        }

        .history-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .history-actions button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .history-actions button:hover {
            background: #4a4a4a;
        }

        /* DAG Config Panel */
        .dag-config-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 300px;
            background: #2a2a2a;
            border-left: 1px solid #3a3a3a;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .dag-config-panel.open {
            transform: translateX(0);
        }

        .dag-config-panel-header {
            padding: 16px;
            background: #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dag-config-panel-header h3 {
            margin: 0;
        }

        .dag-config-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .dag-config-panel label {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            color: #aaa;
        }

        .dag-config-panel input,
        .dag-config-panel select,
        .dag-config-panel textarea {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 12px;
            font-family: inherit;
        }

        .dag-config-panel textarea {
            min-height: 80px;
            resize: vertical;
        }

        .dag-config-panel button {
            width: 100%;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
        }

        .dag-config-panel button:hover {
            background: #4a4a4a;
        }

        .dag-config-panel button.danger {
            background: #5a2a2a;
            border-color: #7a3a3a;
        }

        .dag-config-panel button.danger:hover {
            background: #7a3a3a;
        }

        /* Toggle switch for rotation */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .toggle-switch input[type="checkbox"] {
            width: 40px;
            height: 22px;
            appearance: none;
            background: #3a3a3a;
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            margin: 0;
        }

        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #888;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.2s;
        }

        .toggle-switch input[type="checkbox"]:checked {
            background: #4a9eff;
        }

        .toggle-switch input[type="checkbox"]:checked::before {
            background: white;
            left: 20px;
        }

        #file-input {
            display: none;
        }

        @media (max-width: 768px) {
            .message {
                max-width: 95%;
            }

            .input-row {
                flex-wrap: wrap;
            }

            .dag-config-panel {
                width: 100%;
            }

            .dag-node {
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="tabs">
        <button class="tab active" data-tab="chat">Chat</button>
        <button class="tab" data-tab="dag">DAG</button>
        <button class="tab" data-tab="history">History</button>
        <button class="tab" data-tab="settings">Settings</button>
    </div>

    <div id="chat-tab" class="tab-content active">
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <div class="attached-files" id="attached-files"></div>
            <div class="input-row">
                <input type="file" id="file-input" multiple accept="*/*">
                <div class="input-controls">
                    <button class="file-upload-btn" onclick="document.getElementById('file-input').click()">Attach</button>
                    <button class="model-select" onclick="switchTab('dag')">Edit DAG</button>
                    <button class="model-select" onclick="newChat()">New Chat</button>
                </div>
                <div id="edit-indicator">
                    <span>editing</span>
                    <button onclick="cancelEditMode()">cancel</button>
                </div>
                <textarea id="message-input" placeholder="Type a message..."></textarea>
                <div class="send-controls">
                    <button id="send-btn">Send</button>
                    <button id="stop-btn">Stop</button>
                </div>
            </div>
        </div>
    </div>

    <div id="dag-tab" class="tab-content">
        <div id="dag-editor-container">
            <div id="dag-toolbar">
                <button onclick="addDagNode()">+ Add Node</button>
                <select id="dag-template-select" onchange="loadDagTemplate(this.value)">
                    <option value="">Templates...</option>
                    <option value="single">Single Model</option>
                    <option value="chain">Chain (A→B→C)</option>
                    <option value="parallel">Parallel</option>
                    <option value="diamond">Diamond</option>
                    <option value="debate">Debate</option>
                    <option value="critic">Critic Loop</option>
                </select>
                <div class="toggle-switch">
                    <input type="checkbox" id="dag-rotation-toggle" onchange="toggleDagRotation()">
                    <label for="dag-rotation-toggle">Rotation</label>
                </div>
                <button onclick="openDagSettings()">⚙ Settings</button>
                <button onclick="clearDag()" style="margin-left: auto;">Clear DAG</button>
            </div>
            <div id="dag-canvas-container">
                <svg id="dag-canvas"></svg>
            </div>
        </div>
    </div>

    <div id="history-tab" class="tab-content">
        <div class="history-container">
            <div class="settings-section">
                <h3>Conversation History</h3>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="primary" onclick="exportConversation()">Export</button>
                    <button class="primary" onclick="document.getElementById('import-history-input').click()">Import</button>
                    <button onclick="clearHistory()">Clear All</button>
                </div>
                <input type="file" id="import-history-input" accept=".json" style="display: none;" onchange="importHistory(event)">
            </div>
            <div id="history-list"></div>
        </div>
    </div>

    <div id="settings-tab" class="tab-content">
        <div class="settings-container">
            <div class="settings-section">
                <h3>API Keys</h3>
                <input type="text" id="new-api-key-name" placeholder="Key name (e.g., OpenRouter)">
                <input type="text" id="new-api-key-value" placeholder="API key value">
                <button class="primary" onclick="addApiKey()">Add API Key</button>
                <div id="api-keys-list" style="margin-top: 12px;"></div>
            </div>

            <div class="settings-section">
                <h3>System Prompts</h3>
                <input type="text" id="new-prompt-name" placeholder="Prompt name">
                <textarea id="new-prompt-content" placeholder="System prompt content..."></textarea>
                <button class="primary" onclick="addSystemPrompt()">Add Prompt</button>
                <div id="prompts-list" style="margin-top: 12px;"></div>
            </div>

            <div class="settings-section">
                <h3>Global Settings</h3>
                <label>User Identifier (for multi-model chats):</label>
                <input type="text" id="user-identifier-input" placeholder="Human" onchange="saveUserIdentifier()">
                <div class="toggle-switch">
                    <input type="checkbox" id="latex-toggle" onchange="toggleLatex()">
                    <label for="latex-toggle">Enable LaTeX rendering</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="markdown-toggle" onchange="toggleMarkdown()">
                    <label for="markdown-toggle">Enable Markdown rendering</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="thinking-toggle" onchange="toggleThinkingMode()">
                    <label for="thinking-toggle">Enable extended thinking</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="background-audio-toggle" onchange="toggleBackgroundAudio()">
                    <label for="background-audio-toggle">Keep alive in background (iOS)</label>
                </div>
            </div>

            <div class="settings-section">
                <h3>Models</h3>
                <button class="primary" onclick="fetchOpenRouterModels()">Browse OpenRouter Models</button>
                <div id="models-browser" style="max-height: 300px; overflow-y: auto; margin-top: 12px; display: none;"></div>
                <hr style="border-color: #3a3a3a; margin: 16px 0;">
                <h4>Add New Model</h4>
                <input type="text" id="new-model-name" placeholder="Model name (e.g., Claude 3.5)">
                <textarea id="new-model-config" placeholder='{"endpoint": "https://openrouter.ai/api/v1/chat/completions", "model_id": "anthropic/claude-3.5-sonnet", "api_key_id": "your-key-id"}'></textarea>
                <button class="primary" onclick="addModel()">Add Model</button>
                <div id="models-list" style="margin-top: 12px;"></div>
            </div>

            <div class="settings-section">
                <h3>Export/Import All Data</h3>
                <button onclick="exportData()">Export All</button>
                <button onclick="document.getElementById('import-input').click()">Import</button>
                <input type="file" id="import-input" accept=".json" style="display: none;" onchange="importData(event)">
            </div>
        </div>
    </div>

    <!-- DAG Node Config Panel -->
    <div id="dag-config-panel" class="dag-config-panel">
        <div class="dag-config-panel-header">
            <h3>Node Settings</h3>
            <button onclick="closeDagConfigPanel()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">×</button>
        </div>
        <div class="dag-config-panel-body">
            <label>Model:</label>
            <select id="node-model-select"></select>

            <label>System Prompt:</label>
            <select id="node-prompt-select">
                <option value="">Inherit from DAG</option>
            </select>
            <textarea id="node-custom-prompt" placeholder="Or enter custom prompt..."></textarea>

            <label>Context Mode:</label>
            <select id="node-context-mode">
                <option value="inputs-only">Inputs Only</option>
                <option value="inputs-plus-user">Inputs + User Message</option>
                <option value="full-history">Full History</option>
            </select>

            <div class="toggle-switch">
                <input type="checkbox" id="node-strip-reasoning">
                <label for="node-strip-reasoning">Strip reasoning from output</label>
            </div>

            <div class="toggle-switch">
                <input type="checkbox" id="node-is-terminal">
                <label for="node-is-terminal">Terminal node (output to user)</label>
            </div>

            <button onclick="saveNodeConfig()" class="primary" style="background: #4a9eff; border-color: #4a9eff;">Save</button>
            <button onclick="deleteSelectedNode()" class="danger">Delete Node</button>
        </div>
    </div>

    <!-- DAG Settings Panel -->
    <div id="dag-settings-panel" class="dag-config-panel">
        <div class="dag-config-panel-header">
            <h3>DAG Settings</h3>
            <button onclick="closeDagSettingsPanel()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">×</button>
        </div>
        <div class="dag-config-panel-body">
            <label>Global System Prompt:</label>
            <select id="dag-global-prompt-select">
                <option value="">None</option>
            </select>
            <textarea id="dag-custom-prompt" placeholder="Or enter custom global prompt..."></textarea>

            <label>Message History Limit (0 = all):</label>
            <input type="number" id="dag-history-limit" min="0" value="0">

            <label>Response Delay (ms):</label>
            <input type="number" id="dag-response-delay" min="0" value="500">

            <div class="toggle-switch">
                <input type="checkbox" id="dag-include-files">
                <label for="dag-include-files">Include files in history</label>
            </div>

            <div class="toggle-switch">
                <input type="checkbox" id="dag-model-identity">
                <label for="dag-model-identity">Enable model identity</label>
            </div>

            <button onclick="saveDagSettings()" class="primary" style="background: #4a9eff; border-color: #4a9eff;">Save Settings</button>
        </div>
    </div>

    <script>
        // ==================== STATE ====================
        let models = [];
        let apiKeys = [];
        let systemPrompts = [];
        let currentConversation = [];
        let conversationHistory = [];
        let attachedFiles = [];
        let editingMessageIndex = null;
        let isStreaming = false;
        let userStoppedGeneration = false;
        let currentAbortControllers = [];
        let renderTimer = null;

        // DAG State
        let dag = {
            nodes: {},
            edges: {},
            terminalNode: null,
            globalSystemPrompt: null,
            globalCustomPrompt: '',
            rotation: { enabled: false, index: 0 },
            settings: {
                historyLimit: 0,
                responseDelay: 500,
                includeFiles: false,
                modelIdentity: true
            }
        };

        let selectedNodeId = null;
        let isDraggingNode = false;
        let isDrawingEdge = false;
        let dragOffset = { x: 0, y: 0 };
        let edgeStartNode = null;
        let tempEdgeLine = null;

        // Global settings
        let userIdentifier = 'Human';
        let enableLatexRendering = false;
        let enableMarkdownRendering = false;
        let enableExtendedThinking = false;
        let enableBackgroundAudio = false;
        let thinkingEffort = 'high';

        // Audio context for background
        let audioContext = null;
        let silentAudioNode = null;

        // DB
        let db = null;

        // ==================== INITIALIZATION ====================
        async function init() {
            await loadFromStorage();
            if (enableLatexRendering) await loadKaTeX();
            if (enableMarkdownRendering) await loadSnarkdown();
            setupEventListeners();
            updateModelsList();
            updateApiKeysList();
            updatePromptsList();
            updateUserIdentifierInput();
            renderConversation();
            renderHistory();
            renderDag();
        }

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('DAGchatDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }
                };
            });
        }

        async function saveData(key, value) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readwrite');
                const store = transaction.objectStore('settings');
                const request = store.put(value, key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function loadData(key, defaultValue = null) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['settings'], 'readonly');
                const store = transaction.objectStore('settings');
                const request = store.get(key);
                request.onsuccess = () => {
                    resolve(request.result !== undefined ? request.result : defaultValue);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function loadFromStorage() {
            try {
                await initDB();
                models = await loadData('models', []);
                apiKeys = await loadData('apiKeys', []);
                systemPrompts = await loadData('systemPrompts', []);
                currentConversation = await loadData('currentConversation', []);
                conversationHistory = await loadData('conversationHistory', []);
                dag = await loadData('dag', dag);
                userIdentifier = await loadData('userIdentifier', 'Human');
                enableLatexRendering = await loadData('enableLatexRendering', false);
                enableMarkdownRendering = await loadData('enableMarkdownRendering', false);
                enableExtendedThinking = await loadData('enableExtendedThinking', false);
                enableBackgroundAudio = await loadData('enableBackgroundAudio', false);
                thinkingEffort = await loadData('thinkingEffort', 'high');

                // Update UI toggles
                document.getElementById('latex-toggle').checked = enableLatexRendering;
                document.getElementById('markdown-toggle').checked = enableMarkdownRendering;
                document.getElementById('thinking-toggle').checked = enableExtendedThinking;
                document.getElementById('background-audio-toggle').checked = enableBackgroundAudio;
                document.getElementById('dag-rotation-toggle').checked = dag.rotation?.enabled || false;
            } catch (e) {
                console.error('Error loading from storage:', e);
            }
        }

        async function saveToStorage() {
            try {
                await saveData('models', models);
                await saveData('apiKeys', apiKeys);
                await saveData('systemPrompts', systemPrompts);
                await saveData('currentConversation', currentConversation);
                await saveData('conversationHistory', conversationHistory);
                await saveData('dag', dag);
                await saveData('userIdentifier', userIdentifier);
                await saveData('enableLatexRendering', enableLatexRendering);
                await saveData('enableMarkdownRendering', enableMarkdownRendering);
                await saveData('enableExtendedThinking', enableExtendedThinking);
                await saveData('enableBackgroundAudio', enableBackgroundAudio);
                await saveData('thinkingEffort', thinkingEffort);
            } catch (e) {
                console.error('Error saving to storage:', e);
            }
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });

            // Send message
            document.getElementById('send-btn').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Stop button
            document.getElementById('stop-btn').addEventListener('click', stopGeneration);

            // File upload
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // DAG canvas interactions
            const canvas = document.getElementById('dag-canvas-container');
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleCanvasTouchEnd);

            // Double-click to edit node
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');

            if (tabName === 'dag') {
                renderDag();
            }
        }

        // ==================== DAG EDITOR ====================
        function generateId() {
            return 'id-' + Math.random().toString(36).substr(2, 9);
        }

        function addDagNode() {
            if (models.length === 0) {
                alert('Please add at least one model in Settings first.');
                return;
            }

            const id = generateId();
            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();

            dag.nodes[id] = {
                id: id,
                modelIndex: 0,
                position: {
                    x: Math.random() * (rect.width - 150) + 20,
                    y: Math.random() * (rect.height - 100) + 20
                },
                systemPrompt: null,
                customPrompt: '',
                config: {
                    contextMode: 'inputs-plus-user',
                    stripReasoning: false
                }
            };

            // If this is the first node, make it terminal
            if (Object.keys(dag.nodes).length === 1) {
                dag.terminalNode = id;
            }

            saveToStorage();
            renderDag();
        }

        function renderDag() {
            const container = document.getElementById('dag-canvas-container');
            const svg = document.getElementById('dag-canvas');

            // Clear existing nodes (not SVG)
            container.querySelectorAll('.dag-node').forEach(n => n.remove());

            // Clear SVG
            svg.innerHTML = '';

            // Add arrow marker definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#4a9eff"/>
                </marker>
            `;
            svg.appendChild(defs);

            // Render edges
            Object.values(dag.edges).forEach(edge => {
                const fromNode = dag.nodes[edge.from];
                const toNode = dag.nodes[edge.to];
                if (!fromNode || !toNode) return;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromNode.position.x + 60);
                line.setAttribute('y1', fromNode.position.y + 50);
                line.setAttribute('x2', toNode.position.x + 60);
                line.setAttribute('y2', toNode.position.y + 10);
                line.setAttribute('stroke', '#4a9eff');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                line.style.cursor = 'pointer';
                line.dataset.edgeId = edge.id;
                line.addEventListener('click', () => deleteEdge(edge.id));
                svg.appendChild(line);
            });

            // Render nodes
            Object.values(dag.nodes).forEach(node => {
                const div = document.createElement('div');
                div.className = 'dag-node' + (node.id === selectedNodeId ? ' selected' : '') + (node.id === dag.terminalNode ? ' terminal' : '');
                div.dataset.nodeId = node.id;
                div.style.left = node.position.x + 'px';
                div.style.top = node.position.y + 'px';

                const model = models[node.modelIndex] || { name: 'No Model' };
                const isTerminal = node.id === dag.terminalNode;

                div.innerHTML = `
                    <div class="dag-node-title">
                        <span>${escapeHtml(model.name)}</span>
                        ${isTerminal ? '<span style="color: #9a4aff;">★</span>' : ''}
                    </div>
                    <div class="dag-node-body">
                        ${node.config.contextMode}
                        ${node.config.stripReasoning ? ' • stripped' : ''}
                    </div>
                    <div class="dag-node-ports">
                        <div class="dag-port input" data-port="input" data-node="${node.id}"></div>
                        <div class="dag-port output" data-port="output" data-node="${node.id}"></div>
                    </div>
                `;

                container.appendChild(div);
            });

            // Update rotation toggle
            document.getElementById('dag-rotation-toggle').checked = dag.rotation?.enabled || false;
        }

        function handleCanvasMouseDown(e) {
            const node = e.target.closest('.dag-node');
            const port = e.target.closest('.dag-port');

            if (port) {
                // Start drawing edge
                const nodeId = port.dataset.node;
                const portType = port.dataset.port;

                if (portType === 'output') {
                    isDrawingEdge = true;
                    edgeStartNode = nodeId;

                    const svg = document.getElementById('dag-canvas');
                    tempEdgeLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    const startNode = dag.nodes[nodeId];
                    tempEdgeLine.setAttribute('x1', startNode.position.x + 60);
                    tempEdgeLine.setAttribute('y1', startNode.position.y + 50);
                    tempEdgeLine.setAttribute('x2', e.offsetX);
                    tempEdgeLine.setAttribute('y2', e.offsetY);
                    tempEdgeLine.setAttribute('stroke', '#4a9eff');
                    tempEdgeLine.setAttribute('stroke-width', '2');
                    tempEdgeLine.setAttribute('stroke-dasharray', '5,5');
                    svg.appendChild(tempEdgeLine);
                }
                e.preventDefault();
                return;
            }

            if (node) {
                // Start dragging node
                selectedNodeId = node.dataset.nodeId;
                isDraggingNode = true;
                const rect = node.getBoundingClientRect();
                const containerRect = document.getElementById('dag-canvas-container').getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                renderDag();
                e.preventDefault();
            } else {
                // Deselect
                selectedNodeId = null;
                closeDagConfigPanel();
                renderDag();
            }
        }

        function handleCanvasMouseMove(e) {
            if (isDraggingNode && selectedNodeId) {
                const container = document.getElementById('dag-canvas-container');
                const rect = container.getBoundingClientRect();
                dag.nodes[selectedNodeId].position.x = e.clientX - rect.left - dragOffset.x;
                dag.nodes[selectedNodeId].position.y = e.clientY - rect.top - dragOffset.y;
                renderDag();
            }

            if (isDrawingEdge && tempEdgeLine) {
                const container = document.getElementById('dag-canvas-container');
                const rect = container.getBoundingClientRect();
                tempEdgeLine.setAttribute('x2', e.clientX - rect.left);
                tempEdgeLine.setAttribute('y2', e.clientY - rect.top);
            }
        }

        function handleCanvasMouseUp(e) {
            if (isDraggingNode) {
                isDraggingNode = false;
                saveToStorage();
            }

            if (isDrawingEdge) {
                const port = e.target.closest('.dag-port');
                if (port && port.dataset.port === 'input' && port.dataset.node !== edgeStartNode) {
                    // Create edge
                    const toNodeId = port.dataset.node;

                    // Check for cycles
                    if (!wouldCreateCycle(edgeStartNode, toNodeId)) {
                        const edgeId = generateId();
                        dag.edges[edgeId] = {
                            id: edgeId,
                            from: edgeStartNode,
                            to: toNodeId,
                            transform: 'full'
                        };
                        saveToStorage();
                    } else {
                        alert('Cannot create edge: would create a cycle');
                    }
                }

                isDrawingEdge = false;
                edgeStartNode = null;
                if (tempEdgeLine) {
                    tempEdgeLine.remove();
                    tempEdgeLine = null;
                }
                renderDag();
            }
        }

        function handleCanvasTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const fakeEvent = {
                    target: document.elementFromPoint(touch.clientX, touch.clientY),
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    offsetX: touch.clientX - document.getElementById('dag-canvas-container').getBoundingClientRect().left,
                    offsetY: touch.clientY - document.getElementById('dag-canvas-container').getBoundingClientRect().top,
                    preventDefault: () => e.preventDefault()
                };
                handleCanvasMouseDown(fakeEvent);
            }
        }

        function handleCanvasTouchMove(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const fakeEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    offsetX: touch.clientX - document.getElementById('dag-canvas-container').getBoundingClientRect().left,
                    offsetY: touch.clientY - document.getElementById('dag-canvas-container').getBoundingClientRect().top
                };
                handleCanvasMouseMove(fakeEvent);
                e.preventDefault();
            }
        }

        function handleCanvasTouchEnd(e) {
            const touch = e.changedTouches[0];
            const fakeEvent = {
                target: document.elementFromPoint(touch.clientX, touch.clientY),
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            handleCanvasMouseUp(fakeEvent);
        }

        function handleCanvasDoubleClick(e) {
            const node = e.target.closest('.dag-node');
            if (node) {
                selectedNodeId = node.dataset.nodeId;
                openDagConfigPanel();
            }
        }

        function wouldCreateCycle(fromId, toId) {
            // DFS to check if adding edge from->to would create cycle
            const visited = new Set();

            function dfs(nodeId) {
                if (nodeId === fromId) return true;
                if (visited.has(nodeId)) return false;
                visited.add(nodeId);

                for (const edge of Object.values(dag.edges)) {
                    if (edge.from === nodeId) {
                        if (dfs(edge.to)) return true;
                    }
                }
                return false;
            }

            return dfs(toId);
        }

        function deleteEdge(edgeId) {
            if (confirm('Delete this connection?')) {
                delete dag.edges[edgeId];
                saveToStorage();
                renderDag();
            }
        }

        function openDagConfigPanel() {
            if (!selectedNodeId) return;

            const node = dag.nodes[selectedNodeId];
            if (!node) return;

            // Populate model select
            const modelSelect = document.getElementById('node-model-select');
            modelSelect.innerHTML = models.map((m, i) =>
                `<option value="${i}" ${i === node.modelIndex ? 'selected' : ''}>${escapeHtml(m.name)}</option>`
            ).join('');

            // Populate prompt select
            const promptSelect = document.getElementById('node-prompt-select');
            promptSelect.innerHTML = '<option value="">Inherit from DAG</option>' +
                systemPrompts.map(p =>
                    `<option value="${p.id}" ${p.id === node.systemPrompt ? 'selected' : ''}>${escapeHtml(p.name)}</option>`
                ).join('');

            document.getElementById('node-custom-prompt').value = node.customPrompt || '';
            document.getElementById('node-context-mode').value = node.config.contextMode;
            document.getElementById('node-strip-reasoning').checked = node.config.stripReasoning;
            document.getElementById('node-is-terminal').checked = node.id === dag.terminalNode;

            document.getElementById('dag-config-panel').classList.add('open');
        }

        function closeDagConfigPanel() {
            document.getElementById('dag-config-panel').classList.remove('open');
        }

        function saveNodeConfig() {
            if (!selectedNodeId) return;

            const node = dag.nodes[selectedNodeId];
            if (!node) return;

            node.modelIndex = parseInt(document.getElementById('node-model-select').value);
            node.systemPrompt = document.getElementById('node-prompt-select').value || null;
            node.customPrompt = document.getElementById('node-custom-prompt').value;
            node.config.contextMode = document.getElementById('node-context-mode').value;
            node.config.stripReasoning = document.getElementById('node-strip-reasoning').checked;

            if (document.getElementById('node-is-terminal').checked) {
                dag.terminalNode = selectedNodeId;
            } else if (dag.terminalNode === selectedNodeId) {
                dag.terminalNode = null;
            }

            saveToStorage();
            closeDagConfigPanel();
            renderDag();
        }

        function deleteSelectedNode() {
            if (!selectedNodeId) return;

            if (confirm('Delete this node and its connections?')) {
                // Remove edges connected to this node
                for (const edgeId of Object.keys(dag.edges)) {
                    const edge = dag.edges[edgeId];
                    if (edge.from === selectedNodeId || edge.to === selectedNodeId) {
                        delete dag.edges[edgeId];
                    }
                }

                // Remove node
                delete dag.nodes[selectedNodeId];

                // Update terminal if needed
                if (dag.terminalNode === selectedNodeId) {
                    const remaining = Object.keys(dag.nodes);
                    dag.terminalNode = remaining.length > 0 ? remaining[0] : null;
                }

                selectedNodeId = null;
                saveToStorage();
                closeDagConfigPanel();
                renderDag();
            }
        }

        function openDagSettings() {
            // Populate prompt select
            const promptSelect = document.getElementById('dag-global-prompt-select');
            promptSelect.innerHTML = '<option value="">None</option>' +
                systemPrompts.map(p =>
                    `<option value="${p.id}" ${p.id === dag.globalSystemPrompt ? 'selected' : ''}>${escapeHtml(p.name)}</option>`
                ).join('');

            document.getElementById('dag-custom-prompt').value = dag.globalCustomPrompt || '';
            document.getElementById('dag-history-limit').value = dag.settings?.historyLimit || 0;
            document.getElementById('dag-response-delay').value = dag.settings?.responseDelay || 500;
            document.getElementById('dag-include-files').checked = dag.settings?.includeFiles || false;
            document.getElementById('dag-model-identity').checked = dag.settings?.modelIdentity !== false;

            document.getElementById('dag-settings-panel').classList.add('open');
        }

        function closeDagSettingsPanel() {
            document.getElementById('dag-settings-panel').classList.remove('open');
        }

        function saveDagSettings() {
            dag.globalSystemPrompt = document.getElementById('dag-global-prompt-select').value || null;
            dag.globalCustomPrompt = document.getElementById('dag-custom-prompt').value;
            dag.settings = {
                historyLimit: parseInt(document.getElementById('dag-history-limit').value) || 0,
                responseDelay: parseInt(document.getElementById('dag-response-delay').value) || 500,
                includeFiles: document.getElementById('dag-include-files').checked,
                modelIdentity: document.getElementById('dag-model-identity').checked
            };

            saveToStorage();
            closeDagSettingsPanel();
        }

        function toggleDagRotation() {
            dag.rotation = dag.rotation || { enabled: false, index: 0 };
            dag.rotation.enabled = document.getElementById('dag-rotation-toggle').checked;
            saveToStorage();
        }

        function clearDag() {
            if (confirm('Clear the entire DAG?')) {
                dag.nodes = {};
                dag.edges = {};
                dag.terminalNode = null;
                selectedNodeId = null;
                saveToStorage();
                renderDag();
            }
        }

        // ==================== DAG TEMPLATES ====================
        function loadDagTemplate(template) {
            if (!template) return;

            if (Object.keys(dag.nodes).length > 0) {
                if (!confirm('This will replace your current DAG. Continue?')) {
                    document.getElementById('dag-template-select').value = '';
                    return;
                }
            }

            dag.nodes = {};
            dag.edges = {};

            const container = document.getElementById('dag-canvas-container');
            const rect = container.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            switch (template) {
                case 'single':
                    createTemplateNode('A', centerX - 60, centerY - 40, true);
                    break;

                case 'chain':
                    const chainA = createTemplateNode('A', centerX - 60, 50);
                    const chainB = createTemplateNode('B', centerX - 60, 150);
                    const chainC = createTemplateNode('C', centerX - 60, 250, true);
                    createEdge(chainA, chainB);
                    createEdge(chainB, chainC);
                    break;

                case 'parallel':
                    const par1 = createTemplateNode('Model 1', centerX - 150, centerY - 40, true);
                    const par2 = createTemplateNode('Model 2', centerX + 30, centerY - 40, true);
                    break;

                case 'diamond':
                    const diaTop = createTemplateNode('Input', centerX - 60, 30);
                    const diaLeft = createTemplateNode('Path A', centerX - 150, 130);
                    const diaRight = createTemplateNode('Path B', centerX + 30, 130);
                    const diaBottom = createTemplateNode('Merge', centerX - 60, 230, true);
                    createEdge(diaTop, diaLeft);
                    createEdge(diaTop, diaRight);
                    createEdge(diaLeft, diaBottom);
                    createEdge(diaRight, diaBottom);
                    break;

                case 'debate':
                    const debA = createTemplateNode('Debater A', centerX - 150, 50);
                    const debB = createTemplateNode('Debater B', centerX + 30, 50);
                    const debJudge = createTemplateNode('Judge', centerX - 60, 180, true);
                    createEdge(debA, debJudge);
                    createEdge(debB, debJudge);
                    break;

                case 'critic':
                    const draft = createTemplateNode('Draft', centerX - 60, 30);
                    const critic = createTemplateNode('Critic', centerX - 60, 130);
                    const refine = createTemplateNode('Refine', centerX - 60, 230, true);
                    createEdge(draft, critic);
                    createEdge(critic, refine);
                    break;
            }

            document.getElementById('dag-template-select').value = '';
            saveToStorage();
            renderDag();
        }

        function createTemplateNode(name, x, y, isTerminal = false) {
            const id = generateId();
            dag.nodes[id] = {
                id: id,
                modelIndex: 0,
                position: { x, y },
                systemPrompt: null,
                customPrompt: '',
                config: {
                    contextMode: 'inputs-plus-user',
                    stripReasoning: false
                }
            };

            if (isTerminal) {
                dag.terminalNode = id;
            }

            return id;
        }

        function createEdge(fromId, toId) {
            const id = generateId();
            dag.edges[id] = {
                id: id,
                from: fromId,
                to: toId,
                transform: 'full'
            };
        }

        // ==================== DAG EXECUTION ====================
        function topologicalSort() {
            const result = [];
            const visited = new Set();
            const temp = new Set();

            function visit(nodeId) {
                if (temp.has(nodeId)) {
                    throw new Error('Cycle detected in DAG');
                }
                if (visited.has(nodeId)) return;

                temp.add(nodeId);

                // Visit dependencies (nodes that feed into this one)
                for (const edge of Object.values(dag.edges)) {
                    if (edge.to === nodeId) {
                        visit(edge.from);
                    }
                }

                temp.delete(nodeId);
                visited.add(nodeId);
                result.push(nodeId);
            }

            for (const nodeId of Object.keys(dag.nodes)) {
                if (!visited.has(nodeId)) {
                    visit(nodeId);
                }
            }

            return result;
        }

        function getNodeInputs(nodeId, nodeOutputs) {
            const inputs = [];
            for (const edge of Object.values(dag.edges)) {
                if (edge.to === nodeId && nodeOutputs[edge.from]) {
                    let content = nodeOutputs[edge.from].forwarded;
                    inputs.push({
                        from: edge.from,
                        content: content,
                        transform: edge.transform
                    });
                }
            }
            return inputs;
        }

        function applyOutputTransform(node, fullOutput) {
            if (!node.config.stripReasoning) {
                return fullOutput;
            }

            // Strip thinking/reasoning patterns
            let stripped = fullOutput;
            // Remove <thinking>...</thinking> blocks
            stripped = stripped.replace(/<thinking>[\s\S]*?<\/thinking>/gi, '');
            // Remove [Thinking: ...] blocks
            stripped = stripped.replace(/\[Thinking:[\s\S]*?\]/gi, '');
            // Remove lines starting with common reasoning prefixes
            stripped = stripped.replace(/^(Let me think|I need to|First,|Hmm,|So,).*$/gim, '');
            return stripped.trim();
        }

        async function executeDAG(userMessage) {
            const nodeCount = Object.keys(dag.nodes).length;
            if (nodeCount === 0) {
                throw new Error('No nodes in DAG. Add at least one node.');
            }

            if (!dag.terminalNode) {
                throw new Error('No terminal node set. Double-click a node and set it as terminal.');
            }

            // Create execution record
            const execution = {
                id: generateId(),
                userMessage: userMessage,
                nodeOutputs: {},
                timestamp: new Date().toISOString()
            };

            // Get topological order
            let executionOrder;
            try {
                executionOrder = topologicalSort();
            } catch (e) {
                throw new Error('Invalid DAG: ' + e.message);
            }

            // Apply rotation if enabled
            if (dag.rotation?.enabled && executionOrder.length > 1) {
                const rotateBy = dag.rotation.index % executionOrder.length;
                for (let i = 0; i < rotateBy; i++) {
                    executionOrder.push(executionOrder.shift());
                }
                dag.rotation.index++;
                saveToStorage();
            }

            // Create placeholder message for DAG execution display
            const dagMessage = {
                role: 'assistant',
                isDagExecution: true,
                executionId: execution.id,
                nodeOutputs: {},
                nodeStatus: {},
                timestamp: new Date().toISOString()
            };

            // Initialize node status
            for (const nodeId of executionOrder) {
                dagMessage.nodeStatus[nodeId] = 'waiting';
                dagMessage.nodeOutputs[nodeId] = { full: '', forwarded: '', thinking: '' };
            }

            currentConversation.push(dagMessage);
            renderConversation();

            // Execute nodes in order
            for (const nodeId of executionOrder) {
                if (userStoppedGeneration) break;

                const node = dag.nodes[nodeId];
                if (!node) continue;

                dagMessage.nodeStatus[nodeId] = 'streaming';
                renderConversation();

                try {
                    // Get inputs from upstream nodes
                    const inputs = getNodeInputs(nodeId, dagMessage.nodeOutputs);

                    // Build context based on node config
                    const context = buildNodeContext(node, inputs, userMessage);

                    // Stream response
                    const model = models[node.modelIndex];
                    if (!model) {
                        throw new Error(`Model not found for node`);
                    }

                    const output = await streamNodeResponse(model, node, context, dagMessage, nodeId);

                    dagMessage.nodeOutputs[nodeId] = {
                        full: output.content,
                        forwarded: applyOutputTransform(node, output.content),
                        thinking: output.thinking || ''
                    };

                    dagMessage.nodeStatus[nodeId] = nodeId === dag.terminalNode ? 'terminal' : 'complete';

                } catch (error) {
                    dagMessage.nodeOutputs[nodeId] = {
                        full: `Error: ${error.message}`,
                        forwarded: `Error: ${error.message}`,
                        thinking: ''
                    };
                    dagMessage.nodeStatus[nodeId] = 'complete';
                }

                renderConversation();

                // Add delay between nodes
                if (dag.settings?.responseDelay > 0 && nodeId !== executionOrder[executionOrder.length - 1]) {
                    await new Promise(r => setTimeout(r, dag.settings.responseDelay));
                }
            }

            return dagMessage;
        }

        function buildNodeContext(node, inputs, userMessage) {
            const messages = [];

            switch (node.config.contextMode) {
                case 'inputs-only':
                    // Only include inputs from upstream nodes
                    if (inputs.length > 0) {
                        const inputText = inputs.map(i => {
                            const fromNode = dag.nodes[i.from];
                            const fromModel = models[fromNode?.modelIndex];
                            return `[From ${fromModel?.name || 'Unknown'}]:\n${i.content}`;
                        }).join('\n\n');
                        messages.push({ role: 'user', content: inputText });
                    } else {
                        messages.push({ role: 'user', content: userMessage });
                    }
                    break;

                case 'inputs-plus-user':
                    // Include user message plus inputs
                    let content = userMessage;
                    if (inputs.length > 0) {
                        content += '\n\n--- Previous Analysis ---\n';
                        content += inputs.map(i => {
                            const fromNode = dag.nodes[i.from];
                            const fromModel = models[fromNode?.modelIndex];
                            return `[${fromModel?.name || 'Unknown'}]:\n${i.content}`;
                        }).join('\n\n');
                    }
                    messages.push({ role: 'user', content: content });
                    break;

                case 'full-history':
                    // Include full conversation history
                    let historyLimit = dag.settings?.historyLimit || 0;
                    let historyMessages = currentConversation.filter(m => !m.isDagExecution);

                    if (historyLimit > 0) {
                        historyMessages = historyMessages.slice(-historyLimit);
                    }

                    for (const msg of historyMessages) {
                        if (msg.role === 'user') {
                            messages.push({ role: 'user', content: msg.content });
                        } else if (msg.role === 'assistant' && msg.content) {
                            messages.push({ role: 'assistant', content: msg.content });
                        }
                    }

                    // Add current user message with inputs
                    let fullContent = userMessage;
                    if (inputs.length > 0) {
                        fullContent += '\n\n--- Current Turn Analysis ---\n';
                        fullContent += inputs.map(i => {
                            const fromNode = dag.nodes[i.from];
                            const fromModel = models[fromNode?.modelIndex];
                            return `[${fromModel?.name || 'Unknown'}]:\n${i.content}`;
                        }).join('\n\n');
                    }
                    messages.push({ role: 'user', content: fullContent });
                    break;
            }

            return messages;
        }

        function buildNodeSystemPrompt(node) {
            let prompt = '';

            // Node-specific prompt takes precedence
            if (node.customPrompt) {
                prompt = node.customPrompt;
            } else if (node.systemPrompt) {
                const p = systemPrompts.find(sp => sp.id === node.systemPrompt);
                if (p) prompt = p.content;
            } else if (dag.globalCustomPrompt) {
                prompt = dag.globalCustomPrompt;
            } else if (dag.globalSystemPrompt) {
                const p = systemPrompts.find(sp => sp.id === dag.globalSystemPrompt);
                if (p) prompt = p.content;
            }

            // Add model identity if enabled
            if (dag.settings?.modelIdentity) {
                const model = models[node.modelIndex];
                if (model?.name) {
                    const identity = `You are ${model.name}. `;
                    prompt = identity + prompt;
                }
            }

            return prompt;
        }

        async function streamNodeResponse(model, node, messages, dagMessage, nodeId) {
            const body = {
                model: model.model_id,
                messages: messages,
                stream: true,
                modalities: ["text", "image"]
            };

            // Add optional parameters
            if (model.max_tokens) body.max_tokens = model.max_tokens;
            if (model.temperature !== undefined && model.temperature !== null) body.temperature = model.temperature;
            if (enableExtendedThinking) body.reasoning = { effort: thinkingEffort };

            // Add system prompt
            const systemPrompt = buildNodeSystemPrompt(node);
            if (systemPrompt) {
                body.messages.unshift({ role: 'system', content: systemPrompt });
            }

            const apiKey = resolveApiKey(model);
            if (!apiKey) {
                throw new Error('API key not configured');
            }

            const controller = new AbortController();
            currentAbortControllers.push(controller);

            const response = await fetch(model.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'HTTP-Referer': window.location.href,
                    'X-Title': 'DAGchat'
                },
                body: JSON.stringify(body),
                signal: controller.signal
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error ${response.status}: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let content = '';
            let thinking = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);

                            if (parsed.error) {
                                throw new Error(parsed.error.message || 'API error');
                            }

                            const delta = parsed.choices?.[0]?.delta;

                            if (delta?.content) {
                                if (typeof delta.content === 'string') {
                                    content += delta.content;
                                }
                            }

                            if (delta?.reasoning) {
                                thinking += delta.reasoning;
                            }

                            // Update display
                            dagMessage.nodeOutputs[nodeId] = {
                                full: content,
                                forwarded: applyOutputTransform(node, content),
                                thinking: thinking
                            };
                            scheduleRender();

                        } catch (e) {
                            if (e.message !== 'API error') {
                                console.error('Parse error:', e);
                            } else {
                                throw e;
                            }
                        }
                    }
                }
            }

            return { content, thinking };
        }

        // ==================== MESSAGE HANDLING ====================
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const message = input.value.trim();

            if (!message && attachedFiles.length === 0) return;
            if (isStreaming) return;

            // Check if DAG is configured
            if (Object.keys(dag.nodes).length === 0) {
                alert('Please configure at least one node in the DAG tab first.');
                switchTab('dag');
                return;
            }

            // Handle edit mode
            if (editingMessageIndex !== null) {
                currentConversation = currentConversation.slice(0, editingMessageIndex);
                editingMessageIndex = null;
                showEditIndicator(false);
            }

            // Create user message
            const userMessage = {
                role: 'user',
                content: message,
                files: attachedFiles.length > 0 ? [...attachedFiles] : undefined,
                timestamp: new Date().toISOString()
            };

            currentConversation.push(userMessage);
            input.value = '';
            attachedFiles = [];
            renderAttachedFiles();
            renderConversation();

            // Execute DAG
            isStreaming = true;
            userStoppedGeneration = false;
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();

            try {
                await executeDAG(message);
            } catch (error) {
                console.error('DAG execution error:', error);
                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
            }

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        function showStopButton() {
            document.getElementById('send-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'block';
        }

        function hideStopButton() {
            document.getElementById('send-btn').style.display = 'block';
            document.getElementById('stop-btn').style.display = 'none';
        }

        function stopGeneration() {
            userStoppedGeneration = true;
            for (const controller of currentAbortControllers) {
                try {
                    controller.abort();
                } catch (e) {}
            }
            currentAbortControllers = [];
            isStreaming = false;
            hideStopButton();
            stopBackgroundAudio();
        }

        // ==================== RENDERING ====================
        function scheduleRender() {
            if (renderTimer) return;
            renderTimer = requestAnimationFrame(() => {
                renderTimer = null;
                renderConversation();
            });
        }

        function renderConversation() {
            const container = document.getElementById('chat-messages');
            container.innerHTML = '';

            currentConversation.forEach((msg, index) => {
                if (msg.role === 'user') {
                    renderUserMessage(container, msg, index);
                } else if (msg.isDagExecution) {
                    renderDagExecution(container, msg, index);
                } else if (msg.role === 'assistant') {
                    renderAssistantMessage(container, msg, index);
                }
            });

            container.scrollTop = container.scrollHeight;
        }

        function renderUserMessage(container, msg, index) {
            const div = document.createElement('div');
            div.className = 'message user';

            let html = `<div class="message-content">${escapeHtml(msg.content)}</div>`;

            if (msg.files) {
                for (const file of msg.files) {
                    if (file.type?.startsWith('image/')) {
                        html += `<div class="file-preview"><img src="data:${file.type};base64,${file.base64}" alt="${escapeHtml(file.name)}"></div>`;
                    } else if (file.extractedText) {
                        html += `<div class="file-info">📄 ${escapeHtml(file.name)} - Text extracted</div>`;
                    } else {
                        html += `<div class="file-info">📎 ${escapeHtml(file.name)}</div>`;
                    }
                }
            }

            html += `<div class="message-actions">
                <button onclick="editMessage(${index})">Edit</button>
                <button onclick="regenerateFromMessage(${index})">Regenerate</button>
            </div>`;

            div.innerHTML = html;
            container.appendChild(div);
        }

        function renderDagExecution(container, msg, index) {
            const div = document.createElement('div');
            div.className = 'message dag-execution';

            let html = '<div style="font-size: 12px; color: #888; margin-bottom: 8px;">DAG Execution</div>';

            // Get topological order for display
            let displayOrder;
            try {
                displayOrder = topologicalSort();
            } catch (e) {
                displayOrder = Object.keys(msg.nodeOutputs || {});
            }

            for (const nodeId of displayOrder) {
                const node = dag.nodes[nodeId];
                const model = models[node?.modelIndex];
                const output = msg.nodeOutputs?.[nodeId];
                const status = msg.nodeStatus?.[nodeId] || 'waiting';
                const isTerminal = nodeId === dag.terminalNode;
                const isCollapsed = msg.collapsedNodes?.[nodeId] ?? !isTerminal;

                html += `<div class="dag-node-output">
                    <div class="dag-node-header" onclick="toggleDagNodeOutput(${index}, '${nodeId}')">
                        <span class="node-name">${escapeHtml(model?.name || 'Unknown')} ${isTerminal ? '★' : ''}</span>
                        <span class="node-status ${status}">${status}</span>
                    </div>
                    <div class="dag-node-content ${isCollapsed ? 'collapsed' : ''} ${node?.config?.stripReasoning && !isTerminal ? 'stripped' : ''}" id="dag-output-${index}-${nodeId}">`;

                if (output?.thinking) {
                    const thinkingId = `thinking-${index}-${nodeId}`;
                    html += `<div class="thinking-toggle" onclick="event.stopPropagation(); toggleThinking('${thinkingId}')">Chain of Thought</div>
                        <div id="${thinkingId}" class="thinking-content collapsed">${escapeHtml(output.thinking)}</div>`;
                }

                const content = isTerminal ? output?.full : output?.forwarded;
                html += `${renderMarkdownWithLatex(content || '')}
                    </div>
                </div>`;
            }

            div.innerHTML = html;
            container.appendChild(div);
        }

        function renderAssistantMessage(container, msg, index) {
            const div = document.createElement('div');
            div.className = 'message assistant';

            let html = '';
            if (msg.modelName) {
                html += `<div style="font-size: 12px; color: #888; margin-bottom: 8px;">${escapeHtml(msg.modelName)}</div>`;
            }

            if (msg.thinking) {
                const thinkingId = `thinking-${index}`;
                html += `<div class="thinking-toggle" onclick="toggleThinking('${thinkingId}')">Chain of Thought</div>
                    <div id="${thinkingId}" class="thinking-content collapsed">${escapeHtml(msg.thinking)}</div>`;
            }

            html += `<div class="message-content">${renderMarkdownWithLatex(msg.content || '')}</div>`;

            if (msg.images) {
                for (const img of msg.images) {
                    html += `<div class="file-preview"><img src="${escapeHtml(img.url)}" alt="Generated image"></div>`;
                }
            }

            html += `<div class="message-actions">
                <button onclick="editAssistantMessage(${index})">Edit</button>
                <button onclick="regenerateResponse(${index})">Regenerate</button>
            </div>`;

            div.innerHTML = html;
            container.appendChild(div);
        }

        function toggleDagNodeOutput(msgIndex, nodeId) {
            const msg = currentConversation[msgIndex];
            if (!msg) return;

            msg.collapsedNodes = msg.collapsedNodes || {};
            msg.collapsedNodes[nodeId] = !msg.collapsedNodes[nodeId];

            const element = document.getElementById(`dag-output-${msgIndex}-${nodeId}`);
            if (element) {
                element.classList.toggle('collapsed');
            }
        }

        function toggleThinking(thinkingId) {
            const element = document.getElementById(thinkingId);
            if (element) {
                element.classList.toggle('collapsed');
            }
        }

        // ==================== FILE HANDLING ====================
        async function handleFileUpload(e) {
            const files = Array.from(e.target.files);

            for (const file of files) {
                const fileData = {
                    name: file.name,
                    type: file.type,
                    size: file.size
                };

                if (file.type.startsWith('image/')) {
                    fileData.base64 = await fileToBase64(file);
                } else if (file.type === 'application/pdf') {
                    fileData.extractedText = await extractTextFromPDF(file);
                } else if (file.type.startsWith('text/') || isTextFile(file.name)) {
                    fileData.extractedText = await readTextFile(file);
                }

                attachedFiles.push(fileData);
            }

            renderAttachedFiles();
            e.target.value = '';
        }

        function isTextFile(filename) {
            const textExtensions = ['.txt', '.md', '.json', '.js', '.ts', '.py', '.html', '.css', '.xml', '.csv', '.yaml', '.yml'];
            return textExtensions.some(ext => filename.toLowerCase().endsWith(ext));
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function extractTextFromPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    text += content.items.map(item => item.str).join(' ') + '\n';
                }

                return text.trim();
            } catch (e) {
                console.error('PDF extraction error:', e);
                return '[Could not extract PDF text]';
            }
        }

        function readTextFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => resolve('[Could not read file]');
                reader.readAsText(file);
            });
        }

        function renderAttachedFiles() {
            const container = document.getElementById('attached-files');
            container.innerHTML = attachedFiles.map((file, i) => `
                <div class="attached-file">
                    <span>${escapeHtml(file.name)}</span>
                    <button onclick="removeAttachedFile(${i})">×</button>
                </div>
            `).join('');
        }

        function removeAttachedFile(index) {
            attachedFiles.splice(index, 1);
            renderAttachedFiles();
        }

        // ==================== EDIT/REGENERATE ====================
        function editMessage(index) {
            const msg = currentConversation[index];
            document.getElementById('message-input').value = msg.content;
            editingMessageIndex = index;
            showEditIndicator(true);

            if (msg.files) {
                attachedFiles = [...msg.files];
                renderAttachedFiles();
            }
        }

        function showEditIndicator(show) {
            const indicator = document.getElementById('edit-indicator');
            const input = document.getElementById('message-input');
            indicator.classList.toggle('visible', show);
            input.classList.toggle('editing', show);
        }

        function cancelEditMode() {
            editingMessageIndex = null;
            document.getElementById('message-input').value = '';
            attachedFiles = [];
            renderAttachedFiles();
            showEditIndicator(false);
        }

        function editAssistantMessage(index) {
            const msg = currentConversation[index];
            const content = prompt('Edit response:', msg.content);
            if (content !== null) {
                msg.content = content;
                currentConversation = currentConversation.slice(0, index + 1);
                saveToStorage();
                renderConversation();
            }
        }

        async function regenerateFromMessage(index) {
            if (isStreaming) return;

            currentConversation = currentConversation.slice(0, index + 1);
            renderConversation();

            const userMsg = currentConversation[index];
            if (userMsg.role !== 'user') return;

            isStreaming = true;
            userStoppedGeneration = false;
            currentAbortControllers = [];
            showStopButton();
            startBackgroundAudio();

            try {
                await executeDAG(userMsg.content);
            } catch (error) {
                const errorMessage = {
                    role: 'assistant',
                    content: `Error: ${error.message}`,
                    timestamp: new Date().toISOString()
                };
                currentConversation.push(errorMessage);
            }

            isStreaming = false;
            stopBackgroundAudio();
            currentAbortControllers = [];
            hideStopButton();
            renderConversation();
            saveToStorage();
        }

        async function regenerateResponse(index) {
            // For non-DAG messages, just regenerate
            const msg = currentConversation[index];
            if (msg.isDagExecution) {
                // Find the user message before this
                for (let i = index - 1; i >= 0; i--) {
                    if (currentConversation[i].role === 'user') {
                        await regenerateFromMessage(i);
                        return;
                    }
                }
            }
        }

        // ==================== HISTORY ====================
        function renderHistory() {
            const list = document.getElementById('history-list');
            let html = '';

            if (currentConversation.length > 0) {
                const summary = currentConversation.slice(0, 2).map(msg => {
                    const content = msg.content || '';
                    return `${msg.role}: ${content.substring(0, 50)}...`;
                }).join('\n');

                html += `<div class="history-item">
                    <h4>Current Conversation</h4>
                    <div style="font-size: 13px; color: #aaa;">${escapeHtml(summary)}</div>
                    <div class="history-actions">
                        <button onclick="exportConversation()">Export</button>
                        <button onclick="clearConversation()">Clear</button>
                    </div>
                </div>`;
            }

            if (conversationHistory.length > 0) {
                html += '<h3 style="margin: 20px 0 12px; color: #4a9eff;">Saved</h3>';

                conversationHistory.forEach((entry, i) => {
                    const date = new Date(entry.timestamp).toLocaleString();
                    html += `<div class="history-item">
                        <h4>${escapeHtml(date)}</h4>
                        <div style="font-size: 12px; color: #888;">${entry.messageCount} messages</div>
                        <div class="history-actions">
                            <button onclick="loadConversation(${i})">Load</button>
                            <button onclick="deleteHistoryItem(${i})">Delete</button>
                        </div>
                    </div>`;
                });
            }

            list.innerHTML = html || '<p style="color: #888;">No history yet.</p>';
        }

        function newChat() {
            if (currentConversation.length > 0) {
                conversationHistory.unshift({
                    id: Date.now().toString(),
                    timestamp: new Date().toISOString(),
                    conversation: [...currentConversation],
                    messageCount: currentConversation.length
                });

                if (conversationHistory.length > 50) {
                    conversationHistory = conversationHistory.slice(0, 50);
                }
            }

            currentConversation = [];
            attachedFiles = [];
            editingMessageIndex = null;
            showEditIndicator(false);
            saveToStorage();
            renderConversation();
            renderHistory();
            renderAttachedFiles();
            document.getElementById('message-input').value = '';
        }

        function loadConversation(index) {
            if (!confirm('Load this conversation?')) return;
            currentConversation = [...conversationHistory[index].conversation];
            saveToStorage();
            renderConversation();
            switchTab('chat');
        }

        function deleteHistoryItem(index) {
            if (!confirm('Delete this conversation?')) return;
            conversationHistory.splice(index, 1);
            saveToStorage();
            renderHistory();
        }

        function clearConversation() {
            if (!confirm('Clear current conversation?')) return;
            currentConversation = [];
            saveToStorage();
            renderConversation();
            renderHistory();
        }

        function clearHistory() {
            if (!confirm('Clear ALL history?')) return;
            conversationHistory = [];
            currentConversation = [];
            saveToStorage();
            renderConversation();
            renderHistory();
        }

        function exportConversation() {
            downloadJSON({
                conversation: currentConversation,
                dag: dag,
                timestamp: new Date().toISOString()
            }, `dagchat-${Date.now()}.json`);
        }

        function importHistory(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.conversation) {
                        currentConversation = data.conversation;
                        if (data.dag) dag = data.dag;
                        saveToStorage();
                        renderConversation();
                        renderDag();
                        alert('Imported!');
                        switchTab('chat');
                    }
                } catch (e) {
                    alert('Import error: ' + e.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ==================== SETTINGS ====================
        function addApiKey() {
            const name = document.getElementById('new-api-key-name').value.trim();
            const value = document.getElementById('new-api-key-value').value.trim();

            if (!name || !value) {
                alert('Please enter both name and value');
                return;
            }

            apiKeys.push({
                id: generateId(),
                name: name,
                value: value
            });

            document.getElementById('new-api-key-name').value = '';
            document.getElementById('new-api-key-value').value = '';
            saveToStorage();
            updateApiKeysList();
        }

        function deleteApiKey(id) {
            apiKeys = apiKeys.filter(k => k.id !== id);
            saveToStorage();
            updateApiKeysList();
        }

        function updateApiKeysList() {
            const list = document.getElementById('api-keys-list');
            list.innerHTML = apiKeys.map(key => `
                <div class="api-key-item">
                    <h4>${escapeHtml(key.name)}</h4>
                    <div style="font-size: 12px; color: #888;">${key.value.substring(0, 10)}...</div>
                    <button onclick="deleteApiKey('${key.id}')" style="margin-top: 8px;">Delete</button>
                </div>
            `).join('');
        }

        function addSystemPrompt() {
            const name = document.getElementById('new-prompt-name').value.trim();
            const content = document.getElementById('new-prompt-content').value.trim();

            if (!name || !content) {
                alert('Please enter both name and content');
                return;
            }

            systemPrompts.push({
                id: generateId(),
                name: name,
                content: content
            });

            document.getElementById('new-prompt-name').value = '';
            document.getElementById('new-prompt-content').value = '';
            saveToStorage();
            updatePromptsList();
        }

        function deletePrompt(id) {
            systemPrompts = systemPrompts.filter(p => p.id !== id);
            saveToStorage();
            updatePromptsList();
        }

        function updatePromptsList() {
            const list = document.getElementById('prompts-list');
            list.innerHTML = systemPrompts.map(prompt => `
                <div class="prompt-item">
                    <h4>${escapeHtml(prompt.name)}</h4>
                    <div style="font-size: 12px; color: #888;">${escapeHtml(prompt.content.substring(0, 100))}...</div>
                    <button onclick="deletePrompt('${prompt.id}')" style="margin-top: 8px;">Delete</button>
                </div>
            `).join('');
        }

        function addModel() {
            const name = document.getElementById('new-model-name').value.trim();
            const config = document.getElementById('new-model-config').value.trim();

            if (!name || !config) {
                alert('Please enter both name and config');
                return;
            }

            try {
                const parsed = JSON.parse(config);
                parsed.name = name;
                models.push(parsed);

                document.getElementById('new-model-name').value = '';
                document.getElementById('new-model-config').value = '';
                saveToStorage();
                updateModelsList();
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        function deleteModel(index) {
            models.splice(index, 1);
            saveToStorage();
            updateModelsList();
        }

        function updateModelsList() {
            const list = document.getElementById('models-list');
            list.innerHTML = models.map((model, i) => `
                <div class="model-item">
                    <h4>${escapeHtml(model.name)}</h4>
                    <div style="font-size: 12px; color: #888;">${escapeHtml(model.model_id || 'No model ID')}</div>
                    <div class="model-actions">
                        <button onclick="editModel(${i})">Edit</button>
                        <button onclick="deleteModel(${i})">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function editModel(index) {
            const model = models[index];
            const name = model.name;
            const config = { ...model };
            delete config.name;

            document.getElementById('new-model-name').value = name;
            document.getElementById('new-model-config').value = JSON.stringify(config, null, 2);

            models.splice(index, 1);
            saveToStorage();
            updateModelsList();
        }

        async function fetchOpenRouterModels() {
            const browser = document.getElementById('models-browser');
            browser.style.display = 'block';
            browser.innerHTML = '<p>Loading models...</p>';

            try {
                const response = await fetch('https://openrouter.ai/api/v1/models');
                const data = await response.json();

                let html = '<input type="text" id="model-search" placeholder="Search models..." oninput="filterOpenRouterModels()" style="margin-bottom: 12px;">';
                html += '<div id="model-results">';

                data.data.sort((a, b) => (b.created || 0) - (a.created || 0)).slice(0, 100).forEach(model => {
                    html += `<div class="model-item" onclick="selectOpenRouterModel('${escapeHtml(model.id)}', '${escapeHtml(model.name || model.id)}')" style="cursor: pointer;">
                        <h4>${escapeHtml(model.name || model.id)}</h4>
                        <div style="font-size: 11px; color: #888;">${escapeHtml(model.id)}</div>
                    </div>`;
                });

                html += '</div>';
                browser.innerHTML = html;
                window.openRouterModels = data.data;
            } catch (e) {
                browser.innerHTML = `<p style="color: #ff6b6b;">Error loading models: ${e.message}</p>`;
            }
        }

        function filterOpenRouterModels() {
            const search = document.getElementById('model-search').value.toLowerCase();
            const results = document.getElementById('model-results');

            if (!window.openRouterModels) return;

            const filtered = window.openRouterModels.filter(m =>
                (m.name || '').toLowerCase().includes(search) ||
                m.id.toLowerCase().includes(search)
            ).slice(0, 50);

            results.innerHTML = filtered.map(model => `
                <div class="model-item" onclick="selectOpenRouterModel('${escapeHtml(model.id)}', '${escapeHtml(model.name || model.id)}')" style="cursor: pointer;">
                    <h4>${escapeHtml(model.name || model.id)}</h4>
                    <div style="font-size: 11px; color: #888;">${escapeHtml(model.id)}</div>
                </div>
            `).join('');
        }

        function selectOpenRouterModel(id, name) {
            document.getElementById('new-model-name').value = name;
            document.getElementById('new-model-config').value = JSON.stringify({
                endpoint: "https://openrouter.ai/api/v1/chat/completions",
                model_id: id,
                api_key_id: apiKeys.length > 0 ? apiKeys[0].id : "YOUR_API_KEY_ID"
            }, null, 2);

            document.getElementById('models-browser').style.display = 'none';
        }

        function saveUserIdentifier() {
            userIdentifier = document.getElementById('user-identifier-input').value || 'Human';
            saveToStorage();
        }

        function updateUserIdentifierInput() {
            document.getElementById('user-identifier-input').value = userIdentifier;
        }

        function toggleLatex() {
            enableLatexRendering = document.getElementById('latex-toggle').checked;
            if (enableLatexRendering) loadKaTeX();
            saveToStorage();
            renderConversation();
        }

        function toggleMarkdown() {
            enableMarkdownRendering = document.getElementById('markdown-toggle').checked;
            if (enableMarkdownRendering) loadSnarkdown();
            saveToStorage();
            renderConversation();
        }

        function toggleThinkingMode() {
            enableExtendedThinking = document.getElementById('thinking-toggle').checked;
            saveToStorage();
        }

        function toggleBackgroundAudio() {
            enableBackgroundAudio = document.getElementById('background-audio-toggle').checked;
            saveToStorage();
        }

        function resolveApiKey(model) {
            if (model.api_key_id) {
                const key = apiKeys.find(k => k.id === model.api_key_id);
                return key?.value;
            }
            return model.api_key;
        }

        function exportData() {
            downloadJSON({
                models,
                apiKeys,
                systemPrompts,
                dag,
                currentConversation,
                conversationHistory,
                userIdentifier,
                exportDate: new Date().toISOString()
            }, `dagchat-backup-${Date.now()}.json`);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.models) models = data.models;
                    if (data.apiKeys) apiKeys = data.apiKeys;
                    if (data.systemPrompts) systemPrompts = data.systemPrompts;
                    if (data.dag) dag = data.dag;
                    if (data.currentConversation) currentConversation = data.currentConversation;
                    if (data.conversationHistory) conversationHistory = data.conversationHistory;
                    if (data.userIdentifier) userIdentifier = data.userIdentifier;

                    await saveToStorage();
                    await init();
                    alert('Data imported!');
                } catch (e) {
                    alert('Import error: ' + e.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== UTILITIES ====================
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Background audio for iOS
        function startBackgroundAudio() {
            if (!enableBackgroundAudio) return;
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                if (!silentAudioNode) {
                    silentAudioNode = audioContext.createOscillator();
                    silentAudioNode.frequency.value = 0;
                    const gain = audioContext.createGain();
                    gain.gain.value = 0;
                    silentAudioNode.connect(gain);
                    gain.connect(audioContext.destination);
                    silentAudioNode.start();
                }
            } catch (e) {
                console.error('Audio error:', e);
            }
        }

        function stopBackgroundAudio() {
            if (silentAudioNode) {
                try {
                    silentAudioNode.stop();
                } catch (e) {}
                silentAudioNode = null;
            }
        }

        // Lazy load KaTeX
        let katexLoaded = false;
        async function loadKaTeX() {
            if (katexLoaded) return;

            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
            document.head.appendChild(link);

            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });

            katexLoaded = true;
        }

        // Lazy load snarkdown
        let snarkdownLoaded = false;
        async function loadSnarkdown() {
            if (snarkdownLoaded) return;

            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/snarkdown@2.0.0/dist/snarkdown.umd.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });

            snarkdownLoaded = true;
        }

        function renderMarkdownWithLatex(text) {
            if (!text) return '';

            if (!enableLatexRendering && !enableMarkdownRendering) {
                return escapeHtml(text);
            }

            const masks = [];
            let processed = text;

            // Mask code blocks
            processed = processed.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                const id = masks.length;
                masks.push({ type: 'fenced', lang, code });
                return `\x00MASK${id}\x00`;
            });

            processed = processed.replace(/`([^`]+)`/g, (match, code) => {
                const id = masks.length;
                masks.push({ type: 'inline', code });
                return `\x00MASK${id}\x00`;
            });

            // Render LaTeX
            if (enableLatexRendering && typeof katex !== 'undefined') {
                processed = processed.replace(/\$\$([\s\S]+?)\$\$/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        masks.push({ type: 'latex', html: katex.renderToString(latex.trim(), { throwOnError: false, displayMode: true }) });
                    } catch (e) {
                        masks.push({ type: 'text', text: match });
                    }
                    return `\x00MASK${id}\x00`;
                });

                processed = processed.replace(/\$([^\$\n]+)\$/g, (match, latex) => {
                    const id = masks.length;
                    try {
                        masks.push({ type: 'latex', html: katex.renderToString(latex.trim(), { throwOnError: false }) });
                    } catch (e) {
                        masks.push({ type: 'text', text: match });
                    }
                    return `\x00MASK${id}\x00`;
                });
            }

            // Escape remaining text
            processed = escapeHtml(processed);

            // Render markdown
            if (enableMarkdownRendering && typeof snarkdown !== 'undefined') {
                processed = snarkdown(processed);
            }

            // Restore masks
            processed = processed.replace(/\x00MASK(\d+)\x00/g, (match, i) => {
                const mask = masks[+i];
                if (!mask) return '';

                switch (mask.type) {
                    case 'fenced':
                        return `<pre style="background: #2a2a2a; padding: 12px; border-radius: 6px; overflow-x: auto;"><code>${escapeHtml(mask.code)}</code></pre>`;
                    case 'inline':
                        return `<code style="background: #3a3a3a; padding: 2px 6px; border-radius: 3px;">${escapeHtml(mask.code)}</code>`;
                    case 'latex':
                        return mask.html;
                    case 'text':
                        return escapeHtml(mask.text);
                    default:
                        return '';
                }
            });

            return processed;
        }

        // Initialize
        init();
    </script>
</body>
</html>
